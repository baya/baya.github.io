---
layout: post
title: 区块链技术探索(一), 构造比特币的创世区块
---

创世区块即比特币的第一个区块，这个区块只包含了一笔交易我们把此交易叫做创世交易, 并将它记作 Tx0，为了构造创世区块，我们首先要构造 Tx0,
为了构造 Tx0 我们需要理解比特币中的交易的数据结构.

## 1. 解析交易

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_output_of_a_transaction_-_Txout](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29of_each_output_of_a_transaction-_Txout)

**general format of a Bitcoin transaction (inside a block)**


|Field	| Description	|Size |
|-------|--------------|----|
|-------|:--------------|----|
|Version no	|currently 1|	4 bytes|
|In-counter	|positive integer VI = VarInt	|1 - 9 bytes|
|list of inputs	|the first input of the first transaction is also called "coinbase" (its content was ignored in earlier versions)	| \<in-counter\>-many inputs|
|Out-counter	| positive integer VI = VarInt	| 1 - 9 bytes|
|list of outputs|	the outputs of the first transaction spend the mined bitcoins for the block	|\<out-counter\>-many outputs|
|lock_time	|if non-zero and sequence numbers are < 0xFFFFFFFF: block height or timestamp when transaction is final	|4 bytes|  

<br/>
为了确认自己理解了比特币交易的数据结构，最好的方式是自己写一个 parser, 然后使用自己写的这个 parser 去解析比特币交易数据的内容。我们可以使用任何自己熟悉的编程语言去写这个 parser, 但是在这篇文章中我会大部分使用 c 语言, 包括用 c 去写这个 parser, 因为我认为 c 语言是研究区块链技术最直接最方便的工具。

下面的实验中用到的文件 tx0.bin 可以从 [https://github.com/baya/block7days/blob/master/tx0.bin](https://github.com/baya/block7days/blob/master/tx0.bin) 下载或者通过 [webbtc](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b) 下载

### 1.1 解析 Version no

~~~c
/* parse_tx_version.c */

#include <stdio.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);

  printf("Tx Version: %u\n", tx_version);
}
~~~

通过分析 parse_tx_version.c 的代码我们可以看到用 c 语言解析比特币交易的数据结构非常直接: 定义一个 `unsigned int` 类型的 `tx_version` 变量, `tx_version`也是 4 bytes, 然后从 tx0.bin 的开始位置读 1 次, 读取的字节大小是 4 个字节, 这个 4 由 `sizeof(tx_version)` 计算出来, 读取的结果存放到 `tx_version` 变量里，编译上述代码,并执行,我们得到下面的输出:

~~~text
Tx Version: 1
~~~

### 1.2 解析 In-counter

参考: [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer](https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer)

`In-counter` 的结构定义如下:

**Variable length integer**

|Value	|Storage length	|Format|
|-------|---------------|------|
|< 0xFD	|1	|uint8\_t|
|<= 0xFFFF|	3	|0xFD followed by the length as uint16\_t|
|<= 0xFFFF FFFF	|5	|0xFE followed by the length as uint32\_t|
|-	|9	|0xFF followed by the length as uint64_t|

<br/>

解析的步骤如下:

* 读取第 1 个字节, 假设它的值为 `v1`

* 如果 `v1 < 0xF`, 那么 v1 就是 In-counter 的值

* 如果 `v1 == 0xFD`, 那么再读取 2 个字节, 这 2 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFE`, 那么再读取 4 个字节, 这 4 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFF`, 那么再读取 8 个字节, 这 8 个字节存储的值即为 `In-counter` 的值

~~~c

/* parse_tx_vinc.c */

#include <stdio.h>
#include <stdint.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);
  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %lld\n", tx_vin);
  
}

~~~

解析结果:

~~~text
Tx Version: 1
Tx In-counter: 1
~~~

### 1.3 解析 list of inputs


list of inputs 是由一组 Txin 构成的, Txin 的结构如下:

**general format (inside a block) of each input of a transaction - Txin**

|Field	|Description	|Size|
|-------|---------------|----|
|Previous Transaction hash|	doubled SHA256-hashed of a (previous) to-be-used transaction	|32 bytes|
|Previous Txout-index	|non negative integer indexing an output of the to-be-used transaction	|4 bytes|
|Txin-script length	|non negative integer VI = VarInt	|1 - 9 bytes|
|Txin-script / scriptSig	| Script	|\<in-script length\>-many bytes|
|sequence_no	|normally 0xFFFFFFFF; irrelevant unless transaction's lock_time is > 0	|4 bytes|

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin)

为简单起见，我们只解析第一个 Txin, 我们以解析 Previous Transaction hash 为例子来讲讲解析过程。

1. Previous Transaction hash 一共有 32 个字节，为此我们定义一个长度为 32，类型为 `uint8_t` 的数组来存储 Hash, 这个数组定义为 `uint8_t pre_tx_hash[32];`

2. 将 Hash 以 16 进制的形式存储到一个字符串中, 这个字符串定义为 `char pre_tx_hash_str[65]`


详细代码可以通过 [https://github.com/baya/block7days/blob/master/parse_txin.c](https://github.com/baya/block7days/blob/master/parse_txin.c) 查看.

因为 Tx0 的 Previous Transaction hash 是 "0000000000000000000000000000000000000000000000000000000000000000", 有一定的特殊性，为了
确认解析结果是否正确，我们可以解析其他一些不特殊的交易数据，比如 [https://webbtc.com/tx/703fc5...](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7), 编译代码后我们可以给程序提供一个待解析的交易文件名为参数，比如:

`$ ./a.out tx0.bin`

~~~bash
$ ./a.out tx0.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / scriptSig: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff

~~~

或者

`$ ./a.out tx_703fc5ee.bin`

~~~bash
$ ./a.out tx_703fc5ee.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
~~~

我们会发现解析 tx_703fc5ee.bin 的结果中 scriptSig 和 [https://webbtc.com/tx/703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 scriptSig 有些不一样, 一眼可以看出我们自己解析出的 scriptSig 前面多了 47, 这是什么原因导致的呢？回头再看 Txin 的结构表, Txin-script / scriptSig 的描述是一个 [Script(https://en.bitcoin.it/wiki/Script)](https://en.bitcoin.it/wiki/Script), 比特币的 [Script](https://en.bitcoin.it/wiki/Script) 是一个类似 [Forth](http://en.wikipedia.org/wiki/FORTH) 语言的东西，我们自己写的解析器已经可以将 Script 的内容原原本本地读出来了，但是还需要将它翻译下。

[703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 txin 的 scriptSig 的内容如下:

~~~text
scriptSig: "304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

我们自己写的解析器解析 tx_703fc5ee.bin 得到的 scriptSig 的内容如下：

~~~text
scriptSig: "47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

到目前为止, 我们的主要目的是解析 Tx0 的数据结构, 同时我们又通过解析文件 tx_703fc5ee.bin 来做一个参考检验, 我们会先把主要的精力放在解析 tx0.bin 和 tx_703fc5ee.bin 上面，所以在这篇文章中，我们后续的解析工作会继续围绕在 tx0.bin 和 tx_703fc5ee.bin 这两个文件上面, 代码的编写也会主要针对这两个文件。


### 1.4 解析 Txin-script / scriptSig

在这一节中我们将主要讨论解析 tx_703fc5ee.bin 和 tx0.bin 这两个文件的 Txin-script / scriptSig, 其中 tx0.bin 的 Txin-script / scriptSig 的更准确的名字应该是 coinbase.

scriptSig 的结构是: `<Signature> <PubKey>`, 也就是说 scriptSig 分为两部分：第 1 部分是 Signature, 第 2 部分是 PubKey, 那么我们如何将文件 tx_703fc5ee.bin 的 scriptSig 解析成 Signature 和 PubKey 两部分呢?

首先我们看一个表:

[Constants](https://en.bitcoin.it/wiki/Script#Constants)

When talking about scripts, these value-pushing words are usually omitted.

|Word	|Opcode	|Hex	|Input	|Output	|Description|
|-------|-------|-------|-------|-------|-----------|
|OP\_0, OP\_FALSE	|0	    |0x00	|Nothing.|	(empty value)	|An empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)
|N/A	|1-75	|0x01-0x4b	|(special)	|data	|The next opcode bytes is data to be pushed onto the stack|
|OP\_PUSHDATA1	|76	|0x4c	|(special)	|data	|The next byte contains the number of bytes to be pushed onto the stack.|
|OP\_PUSHDATA2	|77	|0x4d	|(special)	|data	|The next two bytes contain the number of bytes to be pushed onto the stack.
|OP\_PUSHDATA4	|78	|0x4e	|(special)	|data	|The next four bytes contain the number of bytes to be pushed onto the stack.
|OP\_1NEGATE	|79	|0x4f	|Nothing.	|-1	    |The number -1 is pushed onto the stack.
|OP\_1, OP\_TRUE|	81	|0x51	|Nothing.|	1	|The number 1 is pushed onto the stack.
|OP\_2-OP\_16	|82-96	|0x52-0x60	|Nothing.	|2-16	The number in the word name (2-16) is pushed onto the stack.

<br/>

为简单起见，我们先只分析 Opcode 为 1-75 的情况, 当 `1 <= Opcode <= 75` 时, Opcode 后面的 Opcode 个字节的数据将被压入到栈中，这个会被压入到栈中的数据就是 Signature 或者 PubKey, 这里的栈是比特币脚本系统的一种数据结构，用于运行 Script.

通过下面的图我们可以更加直观地理解 scriptSig.

![sig-pubkey](/images/sig-pubkey-parse.png)

通过上图我们已经可以手工地解析出 Signature 和 PubKey, 接下来我们通过编写代码来实现解析。

详细代码可以通过链接: [https://github.com/baya/block7days/blob/master/parse_txin_script_sig.c](https://github.com/baya/block7days/blob/master/parse_txin_script_sig.c) 查看.


编译文件 parse_txin_script_sig.c, 然后分别使用 tx0.bin 和 tx_703fc5ee.bin 作为输入文件进行测试，测试结果如下:

~~~bash
$ ./a.out tx0.bin 

Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
~~~

~~~bash
$ ./a.out tx_703fc5ee.bin 

Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
~~~

将上面的测试结果分别与 webbtc.com 上的 [TX-0](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b.json) 和 [TX-703fc5ee](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json)
作比较，我们会发现结果是吻合的。

解析的过程是这样的，首先定义了一系列的宏, 我们只叙述用到的宏:

~~~c
#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define SIG_BUF_SIZE       1000
~~~

`COINBASE_INX` 和 `NULL_HASH` 结合起来使用，用于判断 Txin(交易输入) 是否是 coinbase 类型的输入, 什么是 coinbase 呢? 简单地说就是比特币系统给你输入了一笔钱，这笔钱不是来自任何的个人。如果一个 Txin 的 Previous Txout-index 等于 `COINBASE_INX` 并且 Previous Tx Hash 等于 `NULL_HASH`, 那么这个 Txin 就是 coinbase 类型的输入.

`OP_PUSHDATA0_START` 和 `OP_PUSHDATA0_END` 结合起来使用，用于解析下面的规则:

|Word	|Opcode	|Hex	|Input	|Output	|Description|
|-------|-------|-------|-------|-------|-----------|
|N/A	|1-75	|0x01-0x4b	|(special)	|data	|The next opcode bytes is data to be pushed onto the stack|

<br/>
对于一个非 coinbase 类型的 Txin, 当读取它的 scriptSig 时, 如果 opcode 的值是在 `OP_PUSHDATA0_START` 和 `OP_PUSHDATA0_END` 之间就需要使用上述的规则解析 scriptSig.

`SIG_BUF_SIZE` 用于给 coinbase 和 scriptSig 固定分配一段足够大的内存，因为 coinbase 和 scriptSig 是变长的，如果在程序运行时动态分配内存会是一件比较复杂的事情，所以我们预先设定 `SIG_BUF_SIZE` 为 1000 个字节，足够容纳 coinbase 或者 scriptSig.

然后我们定义 coinbase 和 scriptSig 的数据结构:

~~~c
typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;
~~~

我们用 `struct coinbase_sig` 来存储 coinbase, 用 `struct script_sig` 来存储 scriptSig.

接着定义用于解析 coinbase 和 scriptSig 的函数:

~~~c
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
  } else {
  }

}
~~~

其中 `void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)` 用于解析 coinbase, `void btc_sc_sig(script_sig *sig_ptr, FILE *fp)` 用于解析 scriptSig.

最后实际的解析过程如下, 去掉了一些不相关的代码，

~~~c

  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  script_sig sc_sig;
  coinbase_sig cb_sig;

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }
  
~~~

### 1.5 解析 Txout

Txout 的格式如下:

|Field	|Description	|Size|
|-------|---------------|----|
|value	|non negative integer giving the number of Satoshis(BTC/10^8) to be transfered|	8 bytes|
|Txout-script length	|non negative integer	|1 - 9 bytes VI = VarInt|
|Txout-script / scriptPubKey	|Script	|\<out-script length\>-many bytes|

<br/>


详细代码可以通过 [https://github.com/baya/block7days/blob/master/parse_txout.c](https://github.com/baya/block7days/blob/master/parse_txout.c) 查看.

解析的过程大致如下:

1\. 定义 Txout 的数据结构

~~~c
typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
} tx_out;
~~~

Txout 的 value 的 size 是 8 bytes，所以用一个 uint64_t 类型的变量存储 value。

Txout 的 script length 是一个 1-9 bytes 的 VarInt(即可变长整型), 取最大长度，我们用一个 uint64_t 类型的变量存储 script length。 

使用字符指针指向我们将来要解析出的 scriptPubKey .

2\. 定义用于读取 Txout 的函数

~~~c

tx_out *read_tx_out_list(uint64_t count, FILE *fp)
{
  tx_out *txo_list;
  uint64_t tmp;

  txo_list = (tx_out*) malloc(count * sizeof(tx_out));
  for(uint64_t i=0; i < count; i++){
    txo_list[i].value = btc_uint8(fp);
    tmp = btc_varint(fp);
    txo_list[i].len = tmp;
    txo_list[i].sc_pbk = btc_sc_pbk(txo_list[i].len, fp);
  }

  return txo_list;
}

char *btc_sc_pbk(uint64_t len, FILE *fp)
{
  char *sc_pbk;
  uint8_t *buf;
  sc_pbk = (char *) malloc((2 * len + 1) * sizeof(char));
  buf = (uint8_t *) malloc(len * sizeof(uint8_t));
  fread(buf, sizeof(uint8_t), len, fp);
  cp_sig_hex_to_str(sc_pbk, buf, len);

  return sc_pbk;
}

~~~

3\. 读取和打印 Txout

~~~c

  txo_list = read_tx_out_list(tx_vout, fp);

  for(int i=0; i < tx_vout; i++){
    printf("Txout Value: %llu\n", txo_list[i].value);
    printf("Txout-script length: %llu\n", txo_list[i].len);
    printf("Txout-script / scriptPubkey: %s\n", txo_list[i].sc_pbk);
  }
~~~

其中 `tx_vout` 存储的是 Txout 的 count 值.

调试结果:

`$ ./a.out tx0.bin` 得到输出:

~~~bash
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
Txout Out-counter: 1
Txout Value: 5000000000
Txout-script length: 67
Txout-script / scriptPubkey: 4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac
~~~

`$ ./a.out tx_703fc5ee.bin` 得到输出:

~~~bash
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
Txout Out-counter: 2
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914a31e71f2cfc0327c55cc4026073f06f3e9e1a21a88ac
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914d6bbf4f08d2df7ea32b2930ae4b7436d4ca6fe4b88ac
~~~

Txout Value 以 [Satoshis(BTC/10^8)](https://en.bitcoin.it/wiki/FAQ#What_do_I_call_the_various_denominations_of_bitcoins.3F) 为单位.

现在读取出的 scriptPubkey 是原始的值，在 1.6 节中将解析 scriptPubkey.

### 1.6 解析 Txout-script / scriptPubKey

以 tx_703fc5ee.bin 中的 scriptPubkey 为例子，我们首先人肉翻译 scriptPubKey, 翻译过程如下图所示:

![parse sc pubkey](/images/parse_sc_pubk.jpg)

详细代码可以通过 [https://github.com/baya/block7days/blob/master/parse_txout_script_pbk.c](https://github.com/baya/block7days/blob/master/parse_txout_script_pbk.c) 查看.

解析的过程大致如下:

1\. 定义和 opcode 相关的宏，可以在文件 parse_txout_script_pbk.c 中查看所有已经定义好的 opcode 宏

2\. 定义 scriptPubkey 的数据结构, 并且将 scriptPubkey 与 Txout 关联

```c
#define PBK_STACK_SIZE 50

typedef struct script_pbk {
  char *stack[PBK_STACK_SIZE];
} script_pbk;

typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
  script_pbk *parsed_sc_pbk;
} tx_out;

```

我们通过 `script_pbk *parsed_sc_pbk;` 将 scriptPubkey 和 Txout 关联起来

3\. 定义用于把 opcode 转换为 opcode name 的索引变量.

```c
static char *btc_sc_opcode_names[] = {"OP_FALSE","OP_PUSHDATA0_START","OP_PUSHDATA0_END","OP_PUSHDATA1","OP_PUSHDATA2","OP_PUSHDATA4","OP_1NEGATE",
				      "OP_TRUE","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15",
				      "OP_16","OP_NOP","OP_IF","OP_NOTIF","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK",
				      "OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","OP_ROT","OP_SWAP","OP_TUCK","OP_2DROP",
				      "OP_2DUP","OP_3DUP","OP_2OVER","OP_2ROT","OP_2SWAP","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_SIZE","OP_INVERT",
				      "OP_AND","OP_OR","OP_XOR","OP_EQUAL","OP_EQUALVERIFY","OP_1ADD","OP_1SUB","OP_2MUL","OP_2DIV","OP_NEGATE","OP_ABS",
				      "OP_NOT","OP_0NOTEQUAL","OP_ADD","OP_SUB","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_BOOLAND","OP_BOOLOR",
				      "OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL",
				      "OP_MIN","OP_MAX","OP_WITHIN","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CODESEPARATOR","OP_CHECKSIG",
				      "OP_CHECKSIGVERIFY","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","OP_CHECKLOCKTIMEVERIFY","OP_CHECKSEQUENCEVERIFY","OP_PUBKEYHASH",
				      "OP_PUBKEY","OP_INVALIDOPCODE","OP_RESERVED","OP_VER","OP_VERIF","OP_VERNOTIF","OP_RESERVED1","OP_RESERVED2","OP_NOP1","OP_NOP9"};

/* generated by parse_script_optcode_to_c_array.rb */
static uint8_t btc_sc_opcodes[] = {0x00,0x01,0x4b,0x4c,0x4d,0x4e,0x4f,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
				   0x60,0x61,0x63,0x64,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x6d,
				   0x6e,0x6f,0x70,0x71,0x72,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
				   0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,
				   0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb1,0xb2,0xfd,0xfe,0xff,0x50,0x62,0x65,0x66,0x89,0x8a,0xb0,0xb9};

```

4\. 实现解析 scriptPubkey 的函数

```c
script_pbk *btc_parsed_sc_pbk(uint64_t len, FILE *fp)
{
  script_pbk *sc_pbk_ptr = malloc(sizeof(script_pbk));
  char **stack_ptr;
  uint64_t i = 0;
  uint8_t opcode;

  stack_ptr = sc_pbk_ptr -> stack;
  do {
    opcode = btc_uint1(fp);
    i += 1;
    if(is_sc_na_constant(opcode)){
      *stack_ptr = (char *)malloc((2 * opcode + 1) * sizeof(char));
      read_op_pushdata0(*stack_ptr, opcode, fp);
      i += opcode;
    } else {
      *stack_ptr = tr_opcode_to_name(opcode);
    }
    ++stack_ptr;
    
  } while(i < len);


  return sc_pbk_ptr;
}

void print_parsed_sc_pbk(script_pbk *sc_pbk)
{
  char **stack_ptr = sc_pbk -> stack;
  printf("Txout-script / Parsed scriptPubkey: ");
  do{
    printf("%s ", *stack_ptr);
    stack_ptr++;
  } while(*stack_ptr);

  printf("\n");
}

int is_sc_na_constant(uint8_t opcode)
{
  if(opcode >= OP_PUSHDATA0_START && opcode <= OP_PUSHDATA0_END){
    return 1;
  } else {
    return 0;
  }
}

char *tr_opcode_to_name(uint8_t opcode)
{
  int i;
  char *res;
  size_t n = sizeof(btc_sc_opcodes) / sizeof(btc_sc_opcodes[0]);
  for(i = 0; i < n; i++)
  {
    if(btc_sc_opcodes[i] == opcode){
      break;
    }
  }

  if(i < n){
    res = btc_sc_opcode_names[i];
  } else {
    res = NO_FOUND_OPTCODE;
  }

  return res;
}

```

我们将解析出来的 scriptPubkey 存储到 `parsed_sc_pbk` 中, 

```c
txo_list[i].parsed_sc_pbk = btc_parsed_sc_pbk(txo_list[i].len, fp);
```

`parsed_sc_pbk` 其实是一个指针变量，我们用它指向 scriptPubkey 所存储的地址.

调试的结果如下:

`$ ./a.out tx0.bin`

```
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
Txout Out-counter: 1
Txout Value: 5000000000
Txout-script length: 67
Txout-script / scriptPubkey: 4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac
Txout-script / Parsed scriptPubkey: 04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f OP_CHECKSIG 
```

`$ ./a.out tx_703fc5ee.bin`

```
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
Txout Out-counter: 2
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914a31e71f2cfc0327c55cc4026073f06f3e9e1a21a88ac
Txout-script / Parsed scriptPubkey: OP_DUP OP_HASH160 a31e71f2cfc0327c55cc4026073f06f3e9e1a21a OP_EQUALVERIFY OP_CHECKSIG 
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914d6bbf4f08d2df7ea32b2930ae4b7436d4ca6fe4b88ac
Txout-script / Parsed scriptPubkey: OP_DUP OP_HASH160 d6bbf4f08d2df7ea32b2930ae4b7436d4ca6fe4b OP_EQUALVERIFY OP_CHECKSIG 
```

调试的结果和在 [webbtc-tx0](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b.json), [webbtc-tx703fc5ee](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 上查询的结果一致.


## 2. 构造创世交易

我们可以认为一笔交易由三部分构成:

1\. 交易自身的数据, 这些数据有: Version no, In-counter, Out-counter, lock_time 等;

2\. 交易输入数据, 记作 Txin;

3\. 交易输出数据, 记作 Txout;

### 2.1 构造交易的演示程序

首先我们给出一张创世交易 TX0 的简化图,

![Tx0简化图](/images/Tx0_in_out.jpg)

在上面的图中，我们将 TX0 的其他信息去掉了，只保留了 Txin 和 Txout 两部分的信息, 其中 In 部分包含一个 scriptSig, Out 部分包含一个 scriptPubKey.

TX0 的交易类型是: Obsolete pay-to-pubkey transaction. Obsolete 是 **_过时_** 的意思, 即 TX0 使用了 pay-to-pubkey 这种过时的交易类型，pay-to-pubkey 虽然过时了，但是比特币系统仍然会认为这种交易是合法的或者认为包含这种过时交易的历史数据是合法的。

pay-to-pubkey 这种交易的 Checking process 如下:

|Stack|	Script|	Description|
|-----|-------|------------|
|Empty.|	<sig> <pubKey> OP_CHECKSIG	|scriptSig and scriptPubKey are combined.|
|\<sig\> \<pubKey\>	|OP_CHECKSIG	|Constants are added to the stack.|
|true	|Empty.	|Signature is checked for top two stack items.|

<br/>

我们注意这句话: **_scriptSig and scriptPubKey are combined_**, 这句话的意思是将 scriptSig 和 scriptPubKey 合并起来, 如果我们刨去一些细节然后对
Checking process 进行提炼，那么 Checking process 的核心可以理解为,

> 将 scriptSig 和 scriptPubKey 两个脚本合并为一个脚本，然后执行合并后的脚本.

我们回到 TX0 中, TX0 中已经包含了一个 scriptSig 和一个 scriptPubKey, 那么 Checking process 是要将 TX0 中的 scriptSig 和 scriptPubKey 和并起来吗？显然不是这样的, 这里的 scriptSig 和 scriptPubKey 虽然处在同一笔交易即 TX0 中，但是两者其实是没有联系的。scriptPubKey 要合并的对象是下一笔交易的 Txin 中的 scriptSig. 在这里我们依然刨去一些细节，对创建交易这一过程进行一个抽象:

> 已知脚本 P, 求一脚本 S, 这个 S 满足条件: 当 S 和 P 按序合并为脚本 SP, 执行脚本 SP 后能够得到预期结果, 比如结果为 True.

现在我们根据上述抽象出来的概念来解释下为什么窃取了 private key, 就能窃取比特币。

![bitcoin 转移简化图](/images/bitcoin_trans2.jpg)

1\. 首先构造一个不含 scriptSig 的交易, 记作 Tx\_unsig

2\. 对 Tx\_unsig 作一个数字摘要，将此摘要记作 Dtxu

3\. 用公钥 pbk\_A 对应的私钥 prk\_A 对数字摘要 Dtxu 进行一个加密 得到 SigD, 这个 SigD 就是我们要求的 scriptSig: S

4\. 将 S 放到 Tx\_unsig 中，这时就生成了一个包含 scriptSig 的完整的交易 Tx\_sig

公钥 pbk\_A 能够将 S 解密成 Dtxu, `<S> <pbk_A> OP_CHECKSIG` 的求值结果为 `True`, 所以 Tx\_sig 将是一笔合法的交易。

由于我并没有中本聪的私钥，所以我没有办法用代码去演示怎么转移掉 TX0 中的 50 个比特币，但是我们仍然可以对 [Block#170](https://webbtc.com/block/00000000d1145790a8694403d4063f323d499e655c83426834d4ce2f8dd4a2ee) 中的已经发生的交易用代码进行分析并演示怎么创建可用的交易。

![block#170交易演示](/images/block170_tx_demo.jpg)

我们的演示程序将分为客户端和服务端两部分, 客户端程序创建交易数据，并将数据通过网络提交给服务端，服务端程序将验证交易数据，并保存交易数据。
那么客户端怎么和服务端通信呢？答案是我们需要制定一些协议来指导两者间的通信。当然比特币已经有了一套比较完备的协议，我们
直接使用比特币的协议即可。由于我们要做的只是一个 demo 程序，我们并不需要把比特币的所有协议都实现，我们只需要实现其中和交易相关的协议。

#### 2.1.1 Message structure 即消息结构

这是一个通用的结构(Common structures), 即比特币节点之间的每一个消息的结构都是相同的, 当然消息的内容(payload)是不同的。

[https://en.bitcoin.it/wiki/Protocol_documentation#Message_structure](https://en.bitcoin.it/wiki/Protocol_documentation#Message_structure)

**Message structure**

|Field Size	|Description	|Data type	|Comments|
|-----------|---------------|-----------|--------|
|4	|magic	|uint32_t	|Magic value indicating message origin network, and used to seek to next message when stream state is unknown|
|12	|command	|char[12]	|ASCII string identifying the packet content, NULL padded (non-NULL padding results in packet rejected)|
|4	|length	|uint32_t	|Length of payload in number of bytes|
|4	|checksum	|uint32_t	|First 4 bytes of sha256(sha256(payload))|
| ?	|payload	|uchar[]	|The actual data|

<br/>

已有的 magic values:

|Network|	Magic value	|Sent over wire as|
|-------|---------------|-----------------|
|main	|0xD9B4BEF9	|F9 BE B4 D9|
|testnet|	0xDAB5BFFA|	FA BF B5 DA|
|testnet3|	0x0709110B|	0B 11 09 07|
|namecoin|	0xFEB4BEF9|	F9 BE B4 FE|

<br/>

我们的 demo 程序将参照上面的 message structure 构造 message.

#### 2.1.2 Message types 即消息类型

[https://en.bitcoin.it/wiki/Protocol_documentation#Message_types](https://en.bitcoin.it/wiki/Protocol_documentation#Message_types)

比特币的消息类型很多，我们暂时只分析 version, verack, tx 这3种消息，因为客户端发送一笔交易只涉及到这3种消息。

下面 3 种消息的通用结构是一致的, 不同的是 payload 结构，所以我们只分析它们的 payload 结构.

1\. **version**

在发送交易之前，我们首先要发送 version 消息

[https://en.bitcoin.it/wiki/Protocol_documentation#version](https://en.bitcoin.it/wiki/Protocol_documentation#version)

|Field Size|	Description	|Data type	|Comments|
|----------|----------------|-----------|--------|
|4	|version	|int32_t	|Identifies protocol version being used by the node|
|8	|services	|uint64_t	|bitfield of features to be enabled for this connection|
|8	|timestamp	|int64_t	|standard UNIX timestamp in seconds|
|26	|addr_recv	|net_addr	|The network address of the node receiving this message|
|Fields below require version ≥ 106|
|26	|addr_from	|net_addr	|The network address of the node emitting this message|
|8	|nonce	|uint64_t	|Node random nonce, randomly generated every time a version packet is sent. This nonce is used to detect connections to self.|
| ?	|user_agent	|var_str|	User Agent (0x00 if string is 0 bytes long)|
|4	|start_height	|int32_t	|The last block received by the emitting node|
|Fields below require version ≥ 70001|
|1	|relay	|bool	|Whether the remote peer should announce relayed transactions or not, see BIP 0037|

<br/>

2\. **verack**

[https://en.bitcoin.it/wiki/Protocol_documentation#verack](https://en.bitcoin.it/wiki/Protocol_documentation#verack)

> The verack message is sent in reply to version. This message consists of only a message header with the command string "verack".

也就是说 verack 消息是用于反馈 version 消息的，并且只有 message header, 没有 payload, 并且它的 header 包含字符串 "verack".

Hexdump of the verack message:

```
0000   F9 BE B4 D9 76 65 72 61  63 6B 00 00 00 00 00 00   ....verack......
0010   00 00 00 00 5D F6 E0 E2                            ........

Message header:
 F9 BE B4 D9                          - Main network magic bytes
 76 65 72 61  63 6B 00 00 00 00 00 00 - "verack" command
 00 00 00 00                          - Payload is 0 bytes long
 5D F6 E0 E2                          - Checksum
```

3\. **tx**

这个才是我们的主角，它的 payload 结构其实就是一个交易: Tx.

[https://en.bitcoin.it/wiki/Protocol_documentation#tx](https://en.bitcoin.it/wiki/Protocol_documentation#tx)

我们已经在第 1 节里对 Tx 的结构做了大量的解析工作，这里就不再重复叙述 Tx 的结构了.

#### 2.1.3 demo 程序设计

虽然只是一个 demo 程序，但是它实现了比特币的一些比较重要的协议，所以我们给出一个设计图，以方便我们后面的编码实现.

![比特币消息流动图](/images/btc_msg_flow.jpg)

#### 2.1.4 实现 version 消息

可以通过链接 [https://github.com/baya/block7days/tree/master/protocols/btc_version](https://github.com/baya/block7days/tree/master/protocols/btc_version) 访问此部分相关的代码.

由于我没有其他机器，这篇文章目前所有的代码都只在 macOS-10.12.6 即 macOS Sierra 上测试过. 编译过程如下:

1\. `cd btc_version`，执行 `make btc_version`

2\. 执行 `./btc_version.out`, 输出:

```text
connected success: 5
Received 150 bytes: ????version
?U9???j?b??f|?ċ
I?/Satoshi:0.14.2/Q????verack]???
```

btc_version 会向真实的 Bitcoin 节点发送 version 消息, 我们可以看到节点向我们反馈了 `/Satoshi:0.14.2/` 的信息. 下面我们介绍下 btc_version 内一些文件的作用和意义.

* [beej_pack.c](https://github.com/baya/block7days/blob/master/protocols/btc_version/beej_pack.c)

beej_pack.c 的主要内容来源于 [http://beej.us/guide/bgnet/output/html/multipage/advanced.html#serialization](http://beej.us/guide/bgnet/output/html/multipage/advanced.html#serialization). 因为 Bitcoin 协议中的很多数据是以 little-endian 形式编码的, 所以我对 beej_pack.c 进行了一些扩展，以使它支持 little-endian 形式的打包和解包,

打包就是编码数据，解包就是解码数据. 

打包的格式如下:

```c
/*
** pack() -- store data dictated by the format string in the buffer
**
**   bits |byte order          float      alignment
**   -----+------------------------------------------
**      < |   little-endian    standard     none
**      > |   big-endian       standard     none
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C         
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (16-bit unsigned length is automatically prepended to strings)
*/ 
```

解包的格式如下:

```c
/*
** unpack() -- unpack data dictated by the format string into the buffer
**
**   bits |byte order          float      alignment
**   -----+------------------------------------------
**      < |   little-endian    standard     none
**      > |   big-endian       standard     none
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C         
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (string is extracted based on its stored length, but 's' can be
**  prepended with a max length)
*/
```

* [kyk_sha.c](https://github.com/baya/block7days/blob/master/protocols/btc_version/kyk_sha.c)

kyk_sha.c 对 openssl 中的 sha256 API 进行了一些简单的封装, 其中的 `kyk_dble_sha256` 函数能够对数据做两次 sha256, 这样就能方便地实现 `sha256(sha256(payload))`,

```c
unsigned char * kyk_dble_sha256(const char *str, size_t len)
{
    unsigned char *dg1;
    unsigned char *dg2;
    
    dg1 = kyk_sha256(str, len);
    dg2 = kyk_sha256((char *)dg1, SHA256_DIGEST_LENGTH);
    
    free(dg1);

    return dg2;
}
```

* [kyk_socket.c](https://github.com/baya/block7days/blob/master/protocols/btc_version/kyk_socket.c)

kyk_socket.c 中的 `kyk_send_btc_msg_buf` 函数对一些 socket API 进行了封装，实现了查找，连接 Bitcoin 服务节点的功能，并能够将打包好的数据发送给 Bitcoin 服务节点。

```c
kyk_send_btc_msg_buf("seed.bitcoin.sipa.be", "8333", &msg_buf);
```

* [btc_message.h](https://github.com/baya/block7days/blob/master/protocols/btc_version/btc_message.h)

btc_message.h 主要是定义了一些和 message, version 相关的数据结构。

* [btc_message.c](https://github.com/baya/block7days/blob/master/protocols/btc_version/btc_message.c)

btc_message.c 主要定义了一个函数: `ptl_msg * unpack_resp_buf(ptl_resp_buf *resp_buf)`, 这个函数的作用是将比特币节点响应的数据解析为可读的消息.当我们向比特币节点发送 version 消息时，我们可以使用 `unpack_resp_buf` 解析节点响应的数据，我们可以得到类似下面的输出:

```text
f9beb4d9 ............................ Start String: Mainnet
76657273696f6e0000000000 ............ Command name
Command name: version
66000000 ............................ Payload size
63e84674 ............................ Checksum
7f1101000c000000000000008d01905900000000000000000000000000000000000000000000ffffaf0b6ec9fdc10c000000000000000000000000000000000000000000000000005e072a53686db942102f5361746f7368693a302e31342e322f4554070001  Payload
f9beb4d976657273696f6e00000000006600000063e846747f1101000c000000000000008d01905900000000000000000000000000000000000000000000ffffaf0b6ec9fdc10c000000000000000000000000000000000000000000000000005e072a53686db942102f5361746f7368693a302e31342e322f4554070001
7f110100 ............................ ptl_ver.vers
0c00000000000000 .................... ptl_ver.servs
8d01905900000000 .................... ptl_ver.ttamp
0000000000000000 .................... ptl_ver.addr_recv_ptr -> servs
00000000000000000000ffffaf0b6ec9 .... ptl_ver.addr_recv_ptr -> ipv
fdc1 ................................ ptl_ver.addr_recv_ptr -> port
0c00000000000000 .................... ptl_ver.addr_from_ptr -> servs
00000000000000000000000000000000 .... ptl_ver.addr_from_ptr -> ipv
0000 ................................ ptl_ver.addr_from_ptr -> port
5e072a53686db942 .................... ptl_ver.nonce
102f ................................ ptl_ver.ua_len
5361746f7368693a302e31342e322f45 .... ptl_ver.uagent
uagent: Satoshi:0.14.2/ET
54070001 ............................ ptl_ver.start_height
7d .................................. ptl_ver.relay
```

通过阅读上面的输出信息, 我们可以知道节点响应给我们的消息类型也是 version, 并且 uagent 是 Satoshi:0.14.2/ET, 注意这里节点响应给我们的 uagent 并不是一成不变的，不同的节点会响应给我们不同的 uagent.

```text
76657273696f6e0000000000 ............ Command name
Command name: version

5361746f7368693a302e31342e322f45 .... ptl_ver.uagent
uagent: Satoshi:0.14.2/ET
```

* [btc_version.c](https://github.com/baya/block7days/blob/master/protocols/btc_version/btc_version.c)

btc_version.c 中包含了 `main` 函数，这个文件的主要作用是填充了 version 消息，并将消息打包，最后将打包好的消息发送给 Bitcoin 节点.


#### 2.1.5 实现 verack 消息

可以通过链接 [https://github.com/baya/block7days/tree/master/protocols/btc_verack](https://github.com/baya/block7days/tree/master/protocols/btc_verack) 访问 verack 相关的代码.

verack 码和 version 的大部分代码是一样的，verack 消息由于没有 payload, 所以它的消息构造比较简单，其 `main` 函数所在的主文件 [btc_verack.c](https://github.com/baya/block7days/blob/master/protocols/btc_verack/btc_verack.c) 也比较简单.

编译 verack,

```bash
$ make btc_verack
```

执行 btc_verack.out,

```bash
$ ./btc_verack.out
```

输出:

```text
connected success: 5
Received 0 bytes: 

=======> Request Buf:
f9beb4d9 ............................ Start String: Mainnet
76657261636b000000000000 ............ Command name
Command name: verack
00000000 ............................ Payload size
5df6e0e2 ............................ Checksum
 .................................... Payload
 
f9beb4d976657261636b000000000000000000005df6e0e2

=======> Response Buf:
00000000 ............................ Start String: Mainnet
000000000000000000000000 ............ Command name
Command name: 
00000000 ............................ Payload size
00000000 ............................ Checksum
 .................................... Payload
 
000000000000000000000000000000000000000000000000
```

从上面打印的信息可以看到比特币节点貌似不会对 verack 消息作出响应，其响应的字节数为 0.

从 [https://en.bitcoin.it/wiki/Protocol_documentation#verack](https://en.bitcoin.it/wiki/Protocol_documentation#verack) 看到一句话,

> The verack message is sent in reply to version.

这句话的意思是: verack 消息是用来响应 version 消息的，按我的猜想应该是客户端在收到节点响应的 version 消息后可以向节点反馈一个 verack 消息.

#### 2.1.6 实现 BTC Echo 服务

BTC Echo 服务是我自己要构建的一个服务，它与比特币的官方协议没有任何关系，我构建这个服务主要是为了达成以下两个目标:

1\. 将客户端发过来的数据解析成对人类友好的可读格式, 以方便调试客户端发送的数据是否正确;

2\. 为后面实现一个可用的比特币 demo 节点搭建一个初步的代码框架;

在编写代码之前, 我们先看一张图，这张图是我从 <<UNIX 网络编程卷1>> 这本书临摹下来的, 我很喜欢这张图，因为它揭示了 TCP 套接字编程的基本套路，所以我用绘图软件对着书本将它一笔一笔地画出来了.

![tcp套接字编程套路](/images/ele-tcp-socket.jpg)

BTC Echo 的代码可以通过 [https://github.com/baya/block7days/tree/master/protocols/btc_echo](https://github.com/baya/block7days/tree/master/protocols/btc_echo) 访问.

主要的逻辑是在 [btc_echo.c](https://github.com/baya/block7days/blob/master/protocols/btc_echo/btc_echo.c) 这个文件中实现的, 并且 btc_echo.c 主要遵循上图所示的套路:

> socket() --> bind() --> listen() --> accept() --> recv() --> send() --> close()

编译和测试步骤如下, 注意这些步骤都是在 btc_echo 目录下执行,

1\. 编译 btc_echo

`$ make btc_echo`

2\. 编译 btc_verack

`$ make btc_verack`

3\. 启动 btc_echo 服务

`$ ./btc_echo.out`

4\. 发起 verack 请求

`$ ./btc_verack.out`

可以得到如下信息:

```text

Received 104 bytes
=======> Response Body:
Magic: f9beb4d9
Command: 76657261636b000000000000
Payload Length: 00000000
Checksum: 5df6e0e2
Payload:

```

BTC echo 服务已经可以将 message header 正确地解析出来，并且将解析后的结果以比较友好的格式发送给请求端.

我们可以继续实验下 echo version 消息的效果.


#### 2.1.7 实现 tx 消息

### 2.2 构建我们自己的创世交易

## 3. 构造创世区块


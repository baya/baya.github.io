---
layout: post
title: 区块链技术探索(一), 自己动手构造比特币的创世区块
categories: 区块链
---

创世区块即比特币的第一个区块，这个区块只包含了一笔交易我们把此交易叫做创世交易, 并将它记作 T0，为了构造创世区块，我们首先要构造 T0,
为了构造 T0 我们需要理解比特币中的交易的数据结构.

## 1. 比特币交易的数据结构

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_output_of_a_transaction_-_Txout](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29of_each_output_of_a_transaction-_Txout)

**general format of a Bitcoin transaction (inside a block)**


|Field	| Description	|Size |
|-------|--------------|----|
|-------|:--------------|----|
|Version no	|currently 1|	4 bytes|
|In-counter	|positive integer VI = VarInt	|1 - 9 bytes|
|list of inputs	|the first input of the first transaction is also called "coinbase" (its content was ignored in earlier versions)	| \<in-counter\>-many inputs|
|Out-counter	| positive integer VI = VarInt	| 1 - 9 bytes|
|list of outputs|	the outputs of the first transaction spend the mined bitcoins for the block	|\<out-counter\>-many outputs|
|lock_time	|if non-zero and sequence numbers are < 0xFFFFFFFF: block height or timestamp when transaction is final	|4 bytes|  

<br/>
为了确认自己理解了比特币交易的数据结构，最好的方式是自己写一个 parser, 然后使用自己写的这个 parser 去解析比特币交易数据的内容。我们可以使用任何自己熟悉的编程语言去写这个 parser, 但是在这篇文章中我会通篇使用 c 语言, 包括用 c 去写这个 parser, 因为我认为 c 语言是研究区块链技术最直接最方便的工具。

下面的实验中用到的文件 tx0.bin 可以从 [https://github.com/baya/block7days/blob/master/tx0.bin](https://github.com/baya/block7days/blob/master/tx0.bin) 下载或者通过 [webbtc](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b) 下载

### 1.1 解析 Version no

~~~c
/* parse_tx_version.c */

#include <stdio.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);

  printf("Tx Version: %u\n", tx_version);
}
~~~

通过分析 parse_tx_version.c 的代码我们可以看到用 c 语言解析比特币交易的数据结构非常直接: 定义一个 `unsigned int` 类型的 `tx_version` 变量, `tx_version`也是 4 bytes, 然后从 tx0.bin 的开始位置读 1 次, 读取的字节大小是 4 个字节, 这个 4 由 `sizeof(tx_version)` 计算出来, 读取的结果存放到 `tx_version` 变量里，编译上述代码,并执行,我们得到下面的输出:

~~~text
Tx Version: 1
~~~

### 1.2 解析 In-counter

参考: [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer](https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer)

`In-counter` 的结构定义如下:

**Variable length integer**

|Value	|Storage length	|Format|
|-------|---------------|------|
|< 0xFD	|1	|uint8\_t|
|<= 0xFFFF|	3	|0xFD followed by the length as uint16\_t|
|<= 0xFFFF FFFF	|5	|0xFE followed by the length as uint32\_t|
|-	|9	|0xFF followed by the length as uint64_t|

<br/>

解析的步骤如下:

* 读取第 1 个字节, 假设它的值为 `v1`

* 如果 `v1 < 0xF`, 那么 v1 就是 In-counter 的值

* 如果 `v1 == 0xFD`, 那么再读取 2 个字节, 这 2 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFE`, 那么再读取 4 个字节, 这 4 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFF`, 那么再读取 8 个字节, 这 8 个字节存储的值即为 `In-counter` 的值

~~~c

/* parse_tx_vinc.c */

#include <stdio.h>
#include <stdint.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);
  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %lld\n", tx_vin);
  
}

~~~

解析结果:

~~~text
Tx Version: 1
Tx In-counter: 1
~~~

### 1.3 解析 list of inputs


list of inputs 是由一组 Txin 构成的, Txin 的结构如下:

**general format (inside a block) of each input of a transaction - Txin**

|Field	|Description	|Size|
|-------|---------------|----|
|Previous Transaction hash|	doubled SHA256-hashed of a (previous) to-be-used transaction	|32 bytes|
|Previous Txout-index	|non negative integer indexing an output of the to-be-used transaction	|4 bytes|
|Txin-script length	|non negative integer VI = VarInt	|1 - 9 bytes|
|Txin-script / scriptSig	| Script	|\<in-script length\>-many bytes|
|sequence_no	|normally 0xFFFFFFFF; irrelevant unless transaction's lock_time is > 0	|4 bytes|

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin)

为简单起见，我们只解析第一个 Txin, 我们以解析 Previous Transaction hash 为例子来讲讲解析过程。

1. Previous Transaction hash 一共有 32 个字节，为此我们定义一个长度为 32，类型为 `uint8_t` 的数组来存储 Hash, 这个数组定义为 `uint8_t pre_tx_hash[32];`

2. 将 Hash 以 16 进制的形式存储到一个字符串中, 这个字符串定义为 `char pre_tx_hash_str[65]`


parse_txin.c 的具体内容如下:

~~~c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sig(char *sig_str, uint64_t len, FILE *fp);

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;

  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  txin_sig = malloc(2*txin_script_len * sizeof(uint8_t) + 1);
  btc_sig(txin_sig, txin_script_len, fp);
  txin_seqno = btc_uint4(fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  printf("Txin-script / scriptSig: %s\n", txin_sig);
  printf("Txin sequence_no: %x\n", txin_seqno);
  

  fclose(fp);
  
}

void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  size_t ret_code = fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_sig(char *sig_str, uint64_t len, FILE *fp)
{
  uint8_t sig_buf[len];
  char buf3[3];
  
  size_t ret_code = fread(sig_buf, sizeof(uint8_t), len, fp);
  for(int64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2 + 1] = '\0';
  
}


~~~

因为 T0 的 Previous Transaction hash 是 "0000000000000000000000000000000000000000000000000000000000000000", 有一定的特殊性，为了
确认解析结果是否正确，我们可以解析其他一些不特殊的交易数据，比如 [https://webbtc.com/tx/703fc5...](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7), 编译代码后我们可以给程序提供一个待解析的交易文件名为参数，比如:

`$ ./a.out tx0.bin`

~~~bash
$ ./a.out tx0.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / scriptSig: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff

~~~

或者

`$ ./a.out tx_703fc5ee.bin`

~~~bash
$ ./a.out tx_703fc5ee.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
~~~

我们会发现解析 tx_703fc5ee.bin 的结果中 scriptSig 和 [https://webbtc.com/tx/703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 scriptSig 有些不一样, 一眼可以看出我们自己解析出的 scriptSig 前面多了 47, 这是什么原因导致的呢？回头再看 Txin 的结构表, Txin-script / scriptSig 的描述是一个 [Script(https://en.bitcoin.it/wiki/Script)](https://en.bitcoin.it/wiki/Script), 比特币的 [Script](https://en.bitcoin.it/wiki/Script) 是一个类似 [Forth](http://en.wikipedia.org/wiki/FORTH) 语言的东西，我们自己写的解析器已经可以将 Script 的内容原原本本地读出来了，但是还需要将它翻译下。

[703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 txin 的 scriptSig 的内容如下:

~~~text
scriptSig: "304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

我们自己写的解析器解析 tx_703fc5ee.bin 得到的 scriptSig 的内容如下：

~~~text
scriptSig: "47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

到目前为止, 我们的主要目的是解析 T0 的数据结构, 同时我们又通过解析文件 tx_703fc5ee.bin 来做一个参考检验, 我们会先把主要的精力放在解析 tx0.bin 和 tx_703fc5ee.bin 上面，所以在这篇文章中，我们后续的解析工作会继续围绕在 tx0.bin 和 tx_703fc5ee.bin 这两个文件上面, 代码的编写也会主要针对这两个文件。


### 1.4 解析 Txin-script / scriptSig

在这一节中我们将主要讨论解析 tx_703fc5ee.bin 和 tx0.bin 这两个文件的 Txin-script / scriptSig, 其中 tx0.bin 的 Txin-script / scriptSig 的更准确的名字应该是 coinbase.

scriptSig 的结构是: `<Signature> <PubKey>`, 也就是说 scriptSig 分为两部分：第 1 部分是 Signature, 第 2 部分是 PubKey, 那么我们如何将文件 tx_703fc5ee.bin 的 scriptSig 解析成 Signature 和 PubKey 两部分呢?

首先我们看一个表:

[Constants](https://en.bitcoin.it/wiki/Script#Constants)

When talking about scripts, these value-pushing words are usually omitted.

|Word	|Opcode	|Hex	|Input	|Output	|Description|
|-------|-------|-------|-------|-------|-----------|
|OP\_0, OP\_FALSE	|0	    |0x00	|Nothing.|	(empty value)	|An empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)
|N/A	|1-75	|0x01-0x4b	|(special)	|data	|The next opcode bytes is data to be pushed onto the stack|
|OP\_PUSHDATA1	|76	|0x4c	|(special)	|data	|The next byte contains the number of bytes to be pushed onto the stack.|
|OP\_PUSHDATA2	|77	|0x4d	|(special)	|data	|The next two bytes contain the number of bytes to be pushed onto the stack.
|OP\_PUSHDATA4	|78	|0x4e	|(special)	|data	|The next four bytes contain the number of bytes to be pushed onto the stack.
|OP\_1NEGATE	|79	|0x4f	|Nothing.	|-1	    |The number -1 is pushed onto the stack.
|OP\_1, OP\_TRUE|	81	|0x51	|Nothing.|	1	|The number 1 is pushed onto the stack.
|OP\_2-OP\_16	|82-96	|0x52-0x60	|Nothing.	|2-16	The number in the word name (2-16) is pushed onto the stack.

<br/>

为简单起见，我们先只分析 Opcode 为 1-75 的情况, 当 `1 <= Opcode <= 75` 时, Opcode 后面的 Opcode 个字节的数据将被压入到栈中，这个会被压入到栈中的数据就是 Signature 或者 PubKey, 这里的栈是比特币脚本系统的一种数据结构，用于运行 Script.

通过下面的图我们可以更加直观地理解 scriptSig.

![sig-pubkey](/images/sig-pubkey-parse.png)

通过上图我们已经可以手工地解析出 Signature 和 PubKey, 接下来我们通过编写代码来实现解析。

parse_txin_script_sig.c 的内容如下: 

~~~c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"

#define OP_FALSE           0x00
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define OP_PUSHDATA1       0x4c
#define OP_PUSHDATA2       0x4d
#define OP_PUSHDATA4       0x4e
#define OP_1NEGATE         0x4f
#define OP_TRUE            0x51
#define OP_2               0x52
#define OP_3               0x53
#define OP_4               0x54
#define OP_5               0x55
#define OP_6               0x56
#define OP_7               0x57
#define OP_8               0x58
#define OP_9               0x59
#define OP_10              0x5a
#define OP_11              0x5b
#define OP_12              0x5c
#define OP_13              0x5d
#define OP_14              0x5e
#define OP_15              0x5f
#define OP_16              0x60

#define SIG_BUF_SIZE       1000

typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;


uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sc_sig(script_sig *sig_ptr, FILE *fp);
void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], const uint64_t len);
void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp);
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp);

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;
  script_sig sc_sig;
  coinbase_sig cb_sig;

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }

  txin_seqno = btc_uint4(fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  if(cb_sig.len > 0){
    printf("Txin-script / coinbase: %s\n", cb_sig.sig);
  }
  if(sc_sig.len > 0){
    printf("Txin-script / scriptSig: %s %s\n", sc_sig.sig, sc_sig.pubkey);
  }
  printf("Txin sequence_no: %x\n", txin_seqno);
  

  fclose(fp);
  
}


void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
  } else {
  }

}


void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp)
{
  uint8_t *sig_buf;
  
  sig_buf = malloc(op_code * sizeof(uint8_t));
  fread(sig_buf, sizeof(uint8_t), op_code, fp);
  cp_sig_hex_to_str(str, sig_buf, op_code);

  free(sig_buf);
}


void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], uint64_t len)
{
  char buf3[3];
  for(int64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2] = '\0';
}

~~~

编译文件 parse_txin_script_sig.c, 然后分别使用 tx0.bin 和 tx_703fc5ee.bin 作为输入文件进行测试，测试结果如下:

~~~bash
$ ./a.out tx0.bin 

Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
~~~

~~~bash
$ ./a.out tx_703fc5ee.bin 

Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
~~~

将上面的测试结果分别与 webbtc.com 上的 [TX-0](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b.json) 和 [TX-703fc5ee](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json)
作比较，我们会发现结果是吻合的。

解析的过程是这样的，首先定义了一系列的宏, 我们只列出用到的宏进行叙述:

~~~c
#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define SIG_BUF_SIZE       1000
~~~

`COINBASE_INX` 和 `NULL_HASH` 结合起来使用，用于判断 Txin(交易输入) 是否是 coinbase 类型的输入, 什么是 coinbase 呢? 简单地说就是比特币系统给你输入了一笔钱，这笔钱不是来自任何的个人。如果一个 Txin 的 Previous Txout-index 等于 `COINBASE_INX` 并且 Previous Tx Hash 等于 `NULL_HASH`, 那么这个 Txin 就是 coinbase 类型的输入.

`OP_PUSHDATA0_START` 和 `OP_PUSHDATA0_END` 结合起来使用，用于解析下面的规则:

|Word	|Opcode	|Hex	|Input	|Output	|Description|
|-------|-------|-------|-------|-------|-----------|
|N/A	|1-75	|0x01-0x4b	|(special)	|data	|The next opcode bytes is data to be pushed onto the stack|

<br/>
对于一个非 coinbase 类型的 Txin, 当读取它的 scriptSig 时, 如果 opcode 的值是在 `OP_PUSHDATA0_START` 和 `OP_PUSHDATA0_END` 之间就需要使用上述的规则解析 scriptSig.

`SIG_BUF_SIZE` 用于给 coinbase 和 scriptSig 固定分配一段足够大的内存，因为 coinbase 和 scriptSig 是变长的，如果在程序运行时动态分配内存会是一件比较复杂的事情，所以我们预先设定 `SIG_BUF_SIZE` 为 1000 个字节，足够容纳 coinbase 或者 scriptSig.

然后我们定义 coinbase 和 scriptSig 的数据结构:

~~~c
typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;
~~~

我们用 `struct coinbase_sig` 来存储 coinbase, 用 `struct script_sig` 来存储 scriptSig.

接着定义用于解析 coinbase 和 scriptSig 的函数:

~~~c
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
  } else {
  }

}
~~~

其中 `void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)` 用于解析 coinbase, `void btc_sc_sig(script_sig *sig_ptr, FILE *fp)` 用于解析 scriptSig.

最后实际的解析过程如下, 去掉了一些不相关的代码，

~~~c

  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  script_sig sc_sig;
  coinbase_sig cb_sig;

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }
  
~~~

### 1.5 解析 Txout

Txout 的格式如下:

|Field	|Description	|Size|
|-------|---------------|----|
|value	|non negative integer giving the number of Satoshis(BTC/10^8) to be transfered|	8 bytes|
|Txout-script length	|non negative integer	|1 - 9 bytes VI = VarInt|
|Txout-script / scriptPubKey	|Script	|\<out-script length\>-many bytes|

<br/>


文件 parse_txout.c 内容:

~~~c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"

#define OP_FALSE           0x00
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define OP_PUSHDATA1       0x4c
#define OP_PUSHDATA2       0x4d
#define OP_PUSHDATA4       0x4e
#define OP_1NEGATE         0x4f
#define OP_TRUE            0x51
#define OP_2               0x52
#define OP_3               0x53
#define OP_4               0x54
#define OP_5               0x55
#define OP_6               0x56
#define OP_7               0x57
#define OP_8               0x58
#define OP_9               0x59
#define OP_10              0x5a
#define OP_11              0x5b
#define OP_12              0x5c
#define OP_13              0x5d
#define OP_14              0x5e
#define OP_15              0x5f
#define OP_16              0x60

#define SIG_BUF_SIZE       1000

typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;

typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
} tx_out;



uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sc_sig(script_sig *sig_ptr, FILE *fp);
void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], const uint64_t len);
void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp);
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp);
tx_out *read_tx_out_list(uint64_t count, FILE *fp);
uint8_t btc_uint1(FILE *fp);
uint64_t btc_uint8(FILE *fp);
char *btc_sc_pbk(uint64_t len, FILE *fp);

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;
  script_sig sc_sig;
  coinbase_sig cb_sig;
  uint64_t tx_vout;
  tx_out *txo_list;
  

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }

  txin_seqno = btc_uint4(fp);
  tx_vout = btc_varint(fp);

  txo_list = read_tx_out_list(tx_vout, fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  if(cb_sig.len > 0){
    printf("Txin-script / coinbase: %s\n", cb_sig.sig);
  }
  if(sc_sig.len > 0){
    printf("Txin-script / scriptSig: %s %s\n", sc_sig.sig, sc_sig.pubkey);
  }
  printf("Txin sequence_no: %x\n", txin_seqno);

  printf("Txout Out-counter: %llu\n", tx_vout);
  for(int i=0; i < tx_vout; i++){
    printf("Txout Value: %llu\n", txo_list[i].value);
    printf("Txout-script length: %llu\n", txo_list[i].len);
    printf("Txout-script / scriptPubkey: %s\n", txo_list[i].sc_pbk);
  }
  

  fclose(fp);
  
}

tx_out *read_tx_out_list(uint64_t count, FILE *fp)
{
  tx_out *txo_list;
  uint64_t tmp;

  txo_list = (tx_out*) malloc(count * sizeof(tx_out));
  for(uint64_t i=0; i < count; i++){
    txo_list[i].value = btc_uint8(fp);
    tmp = btc_varint(fp);
    txo_list[i].len = tmp;
    txo_list[i].sc_pbk = btc_sc_pbk(txo_list[i].len, fp);
  }

  return txo_list;
}

char *btc_sc_pbk(uint64_t len, FILE *fp)
{
  char *sc_pbk;
  uint8_t *buf;
  sc_pbk = (char *) malloc((2 * len + 1) * sizeof(char));
  buf = (uint8_t *) malloc(len * sizeof(uint8_t));
  fread(buf, sizeof(uint8_t), len, fp);
  cp_sig_hex_to_str(sc_pbk, buf, len);

  return sc_pbk;
}

uint64_t btc_uint8(FILE *fp)
{
  uint64_t buf;
  fread(&buf, sizeof(buf), 1, fp);
  return buf;
}

uint8_t btc_uint1(FILE *fp)
{
  uint8_t buf;
  fread(&buf, sizeof(buf), 1, fp);
  return buf;
}


void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
  } else {
  }

}


void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp)
{
  uint8_t *sig_buf;
  
  sig_buf = malloc(op_code * sizeof(uint8_t));
  fread(sig_buf, sizeof(uint8_t), op_code, fp);
  cp_sig_hex_to_str(str, sig_buf, op_code);

  free(sig_buf);
}


void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], uint64_t len)
{
  char buf3[3];
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2] = '\0';
}

~~~

解析的过程大致如下:

1\. 定义 Txout 的数据结构

~~~c
typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
} tx_out;
~~~

Txout 的 value 的 size 是 8 bytes，所以用一个 uint64_t 类型的变量存储 value。

Txout 的 script length 是一个 1-9 bytes 的 VarInt(即可变长整型), 取最大长度，我们用一个 uint64_t 类型的变量存储 script length。 

使用字符指针指向我们将来要解析出的 scriptPubKey .

2\. 定义用于读取 Txout 的函数

~~~c

tx_out *read_tx_out_list(uint64_t count, FILE *fp)
{
  tx_out *txo_list;
  uint64_t tmp;

  txo_list = (tx_out*) malloc(count * sizeof(tx_out));
  for(uint64_t i=0; i < count; i++){
    txo_list[i].value = btc_uint8(fp);
    tmp = btc_varint(fp);
    txo_list[i].len = tmp;
    txo_list[i].sc_pbk = btc_sc_pbk(txo_list[i].len, fp);
  }

  return txo_list;
}

char *btc_sc_pbk(uint64_t len, FILE *fp)
{
  char *sc_pbk;
  uint8_t *buf;
  sc_pbk = (char *) malloc((2 * len + 1) * sizeof(char));
  buf = (uint8_t *) malloc(len * sizeof(uint8_t));
  fread(buf, sizeof(uint8_t), len, fp);
  cp_sig_hex_to_str(sc_pbk, buf, len);

  return sc_pbk;
}

~~~

3\. 读取和打印 Txout

~~~c

  txo_list = read_tx_out_list(tx_vout, fp);

  for(int i=0; i < tx_vout; i++){
    printf("Txout Value: %llu\n", txo_list[i].value);
    printf("Txout-script length: %llu\n", txo_list[i].len);
    printf("Txout-script / scriptPubkey: %s\n", txo_list[i].sc_pbk);
  }
~~~

其中 `tx_vout` 存储的是 Txout 的 count 值.

调试结果:

`$ ./a.out tx0.bin` 得到输出:

~~~bash
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
Txout Out-counter: 1
Txout Value: 5000000000
Txout-script length: 67
Txout-script / scriptPubkey: 4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac
~~~

`$ ./a.out tx_703fc5ee.bin` 得到输出:

~~~bash
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
Txout Out-counter: 2
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914a31e71f2cfc0327c55cc4026073f06f3e9e1a21a88ac
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914d6bbf4f08d2df7ea32b2930ae4b7436d4ca6fe4b88ac
~~~

Txout Value 以 [Satoshis(BTC/10^8)](https://en.bitcoin.it/wiki/FAQ#What_do_I_call_the_various_denominations_of_bitcoins.3F) 为单位.

现在读取出的 scriptPubkey 是原始的值，在 1.6 节中将解析 scriptPubkey.

### 1.6 解析 Txout-script / scriptPubKey

以 tx_703fc5ee.bin 中的 scriptPubkey 为例子，我们首先人肉翻译 scriptPubKey, 翻译过程如下图所示:

![parse sc pubkey](/images/parse_sc_pubk.jpg)

## 2. 构造创世交易

## 3. 解析创世区块

## 4. 构造创世区块

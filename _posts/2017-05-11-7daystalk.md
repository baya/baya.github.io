---
layout: post
title: 区块链技术探索(一), 自己动手构造比特币的创世区块
---

创世区块即比特币的第一个区块，这个区块只包含了一笔交易我们把此交易叫做创世交易, 并将它记作 T0，为了构造创世区块，我们首先要构造 T0,
为了构造 T0 我们需要理解比特币中的交易的数据结构.

## 1. 比特币交易的数据结构

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_output_of_a_transaction_-_Txout](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29of_each_output_of_a_transaction-_Txout)

**general format of a Bitcoin transaction (inside a block)**


|Field	| Description	|Size |
|-------|--------------|----|
|-------|:--------------|----|
|Version no	|currently 1|	4 bytes|
|In-counter	|positive integer VI = VarInt	|1 - 9 bytes|
|list of inputs	|the first input of the first transaction is also called "coinbase" (its content was ignored in earlier versions)	| \<in-counter\>-many inputs|
|Out-counter	| positive integer VI = VarInt	| 1 - 9 bytes|
|list of outputs|	the outputs of the first transaction spend the mined bitcoins for the block	|\<out-counter\>-many outputs|
|lock_time	|if non-zero and sequence numbers are < 0xFFFFFFFF: block height or timestamp when transaction is final	|4 bytes|  

<br/>
为了确认自己理解了比特币交易的数据结构，最好的方式是自己写一个 parser, 使用自己写的这个 parser 去解析比特币交易数据的内容。我们可以使用任何自己熟悉的编程语言去写这个 parser, 但是在这篇文章中我会用通篇使用 c 语言, 包括用 c 去写这个 parser, 因为我认为 c 语言是研究区块链技术最直接最方便的工具。

下面的实验中用到的文件 `tx0.bin` 可以从 [https://github.com/baya/block7days/blob/master/tx0.bin](https://github.com/baya/block7days/blob/master/tx0.bin) 下载或者通过 [webbtc](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b) 下载

### 1.1 解析 `Version no`

~~~c
/* parse_tx_version.c */

#include <stdio.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);

  printf("Tx Version: %u\n", tx_version);
}
~~~

通过分析 `parse_tx_version.c` 的代码我们可以看到用 c 语言解析比特币交易的数据结构非常直接: 定义一个 `unsigned int` 类型的 `tx_version` 变量, `tx_version`也是 4 bytes, 然后从 `tx0.bin` 的开始位置读 1 次, 读取的字节大小是 4 个字节, 这个 4 由 `sizeof(tx_version)` 计算出来, 读取的结果存放到 `tx_version` 变量里，编译上述代码,并执行,我们得到下面的输出:

~~~text
Tx Version: 1
~~~

### 1.2 解析 In-counter

参考: [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer](https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer)

`In-counter` 的结构定义如下:

**Variable length integer**

|Value	|Storage length	|Format|
|-------|---------------|------|
|< 0xFD	|1	|uint8\_t|
|<= 0xFFFF|	3	|0xFD followed by the length as uint16\_t|
|<= 0xFFFF FFFF	|5	|0xFE followed by the length as uint32\_t|
|-	|9	|0xFF followed by the length as uint64_t|

<br/>

解析的步骤如下:

* 读取第 1 个字节, 假设它的值为 `v1`

* 如果 `v1 < 0xFD`, 那么 `v1` 就是 `In-counter` 的值

* 如果 `v1 == 0xFD`, 那么再读取 2 个字节, 这 2 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFE`, 那么再读取 4 个字节, 这 4 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFF`, 那么再读取 8 个字节, 这 8 个字节存储的值即为 `In-counter` 的值

~~~c

/* parse_tx_vinc.c */

#include <stdio.h>
#include <stdint.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);
  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %lld\n", tx_vin);
  
}

~~~

解析结果:

~~~text
Tx Version: 1
Tx In-counter: 1
~~~

### 1.3 解析 list of inputs


`list of inputs` 是由一组 `Txin` 构成的, `Txin` 的结构如下:

**general format (inside a block) of each input of a transaction - Txin**

|Field	|Description	|Size|
|-------|---------------|----|
|Previous Transaction hash|	doubled SHA256-hashed of a (previous) to-be-used transaction	|32 bytes|
|Previous Txout-index	|non negative integer indexing an output of the to-be-used transaction	|4 bytes|
|Txin-script length	|non negative integer VI = VarInt	|1 - 9 bytes|
|Txin-script / scriptSig	| Script	|\<in-script length\>-many bytes|
|sequence_no	|normally 0xFFFFFFFF; irrelevant unless transaction's lock_time is > 0	|4 bytes|

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin)

为简单起见，我们只解析第一个 Txin, 我们以解析 `Previous Transaction hash` 为例子来讲讲解析过程。

1. `Previous Transaction hash` 一共有 32 个字节，为此我们定义一个长度为 32，类型为 `uint8_t` 的数组来存储 `Hash`, 这个数组定义为 `uint8_t pre_tx_hash[32];`

2. 将 `Hash` 以 16 进制的形式存储到一个字符串中, 这个字符串定义为 `char pre_tx_hash_str[65]`


`parse_txin.c` 的具体内容如下:

~~~c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sig(char *sig_str, uint64_t len, FILE *fp);

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;

  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  txin_sig = malloc(2*txin_script_len * sizeof(uint8_t) + 1);
  btc_sig(txin_sig, txin_script_len, fp);
  txin_seqno = btc_uint4(fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  printf("Txin-script / scriptSig: %s\n", txin_sig);
  printf("Txin sequence_no: %x\n", txin_seqno);
  

  fclose(fp);
  
}

void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  size_t ret_code = fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_sig(char *sig_str, uint64_t len, FILE *fp)
{
  uint8_t sig_buf[len];
  char buf3[3];
  
  size_t ret_code = fread(sig_buf, sizeof(uint8_t), len, fp);
  for(int64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2 + 1] = '\0';
  
}


~~~

因为 T0 的 `Previous Transaction hash` 是 `0000000000000000000000000000000000000000000000000000000000000000`, 有一定的特殊性，为了
确认解析结果是否正确，我们可以解析其他一些不特殊的交易数据，比如 [https://webbtc.com/tx/703fc5...](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7), 编译代码后我们可以给程序提供一个待解析的交易文件名为参数，比如:

~~~bash
$ ./a.out tx0.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / scriptSig: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff

~~~

或者

~~~bash
$ ./a.out tx_703fc5ee.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
~~~

我们会发现解析 `tx_703fc5ee.bin` 的结果中 `scriptSig` 和 [https://webbtc.com/tx/703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 `scriptSig` 有些不一样, 一眼可以看出我们自己解析出的 `scriptSig` 前面多了 `47`, 这是什么原因导致的呢？回头再看 `Txin` 的结构表, `Txin-script / scriptSig` 的描述是一个 [Script(https://en.bitcoin.it/wiki/Script)](https://en.bitcoin.it/wiki/Script), 比特币的 [Script](https://en.bitcoin.it/wiki/Script) 是一个类似 [Forth](http://en.wikipedia.org/wiki/FORTH) 语言的东西，我们自己写的解析器已经可以将 `Script`的内容原原本本地读出来了，但是还需要将它翻译下。

[703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 `txin` 的 `scriptSig` 的内容如下:

~~~text
scriptSig: "304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

我们自己写的解析器解析 `tx_703fc5ee.bin` 得到的 `scriptSig` 的内容如下：

~~~text
scriptSig: "47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

到目前为止, 我们的主要目的是解析 T0 的数据结构, 同时我们又通过解析文件 `tx_703fc5ee.bin` 来做一个参考确认, 我们会先把主要的精力放在解析 `tx0.bin` 和 `tx_703fc5ee.bin` 上面，所以在这篇文章中，我们后续的解析工作会继续围绕在 `tx0.bin` 和 `tx_703fc5ee.bin`这两个文件上面, 代码的编写也会主要针对这两个文件。


### 1.4 解析 Txin-script / scriptSig

### 1.5 解析 Txout

### 1.6 解析 Txout-script / scriptPubKey

## 2. 构造 T0

## 3. 解析创世区块

## 4. 构造创世区块

---
layout: post
title: 区块链技术 7 日谈
---

## 第 1 天, 自己动手构造比特币的创世区块

创世区块即比特币的第一个区块，这个区块只包含了一笔交易我们把此交易叫做创世交易, 并将它记作 T0，为了构造创世区块，我们首先要构造 T0,
为了构造 T0 我们需要理解比特币中的交易的数据结构.

### 1. 比特币交易的数据结构

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_output_of_a_transaction_-_Txout](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29of_each_output_of_a_transaction-_Txout)

general format of a Bitcoin transaction (inside a block)


|Field	| Description	|Size |
|-------|--------------|----|
|-------|:--------------|----|
|Version no	|currently 1|	4 bytes|
|In-counter	|positive integer VI = VarInt	|1 - 9 bytes|
|list of inputs	|the first input of the first transaction is also called "coinbase" (its content was ignored in earlier versions)	| \<in-counter\>-many inputs|
|Out-counter	| positive integer VI = VarInt	| 1 - 9 bytes|
|list of outputs|	the outputs of the first transaction spend the mined bitcoins for the block	|\<out-counter\>-many outputs|
|lock_time	|if non-zero and sequence numbers are < 0xFFFFFFFF: block height or timestamp when transaction is final	|4 bytes|  

<br/>
为了确认自己理解了比特币交易的数据结构，最好的方式是自己写一个 parser, 使用自己写的这个 parser 去解析比特币交易数据的内容。我们可以使用任何自己熟悉的编程语言去写这个 parser, 但是在这篇文章中我会用通篇使用 c 语言, 包括用 c 去写这个 parser, 因为我认为 c 语言是研究区块链技术最直接最方便的工具。

下面的实验中用到的文件 `tx0.bin` 可以从 [https://github.com/baya/block7days/blob/master/tx0.bin](https://github.com/baya/block7days/blob/master/tx0.bin) 下载或者通过 [webbtc](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b) 下载

#### 1.1 解析 `Version no`

~~~c
/* parse_tx_version.c */

#include <stdio.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);

  printf("Tx Version: %u\n", tx_version);
}
~~~

通过分析 `parse_tx_version.c` 的代码我们可以看到用 c 语言解析比特币交易的数据结构非常直接: 定义一个 `unsigned int` 类型的 `tx_version` 变量, `tx_version`也是 4 bytes, 然后从 `tx0.bin` 的开始位置读 1 次, 读取的字节大小是 4 个字节, 这个 4 由 `sizeof(tx_version)` 计算出来, 读取的结果存放到 `tx_version` 变量里，编译上述代码,并执行,我们得到下面的输出:

~~~text
Tx Version: 1
~~~

#### 1.2 解析 `In-counter`

参考: [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer](https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer)

`In-counter` 的结构定义如下:

|Value	|Storage length	|Format|
|-------|---------------|------|
|< 0xFD	|1	|uint8\_t|
|<= 0xFFFF|	3	|0xFD followed by the length as uint16\_t|
|<= 0xFFFF FFFF	|5	|0xFE followed by the length as uint32\_t|
|-	|9	|0xFF followed by the length as uint64_t|

<br/>

解析的步骤如下:

* 读取第 1 个字节, 假设它的值为 `v1`

* 如果 `v1 < 0xFD`, 那么 `v1` 就是 `In-counter` 的值

* 如果 `v1 == 0xFD`, 那么再读取 2 个字节, 这 2 个字节存取的值即为 `In-counter` 的值

* 如果 `v1 == 0xFE`, 那么再读取 4 个字节, 这 4 个字节存取的值即为 `In-counter` 的值

* 如果 `v1 == 0xFF`, 那么再读取 8 个字节, 这 8 个字节存取的值即为 `In-counter` 的值

~~~c

/* parse_tx_vinc.c */

#include <stdio.h>
#include <stdint.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);
  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %lld\n", tx_vin);
  
}

~~~

解析结果:

~~~text
Tx Version: 1
Tx In-counter: 1
~~~

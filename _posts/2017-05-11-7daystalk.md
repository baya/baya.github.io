---
layout: post
title: 区块链技术探索(一), 构造比特币的创世区块
---

创世区块即比特币的第一个区块，这个区块只包含了一笔交易我们把此交易叫做创世交易, 并将它记作 T0，为了构造创世区块，我们首先要构造 T0,
为了构造 T0 我们需要理解比特币中的交易的数据结构.

## 1. 解析交易

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_output_of_a_transaction_-_Txout](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29of_each_output_of_a_transaction-_Txout)

**general format of a Bitcoin transaction (inside a block)**


|Field	| Description	|Size |
|-------|--------------|----|
|-------|:--------------|----|
|Version no	|currently 1|	4 bytes|
|In-counter	|positive integer VI = VarInt	|1 - 9 bytes|
|list of inputs	|the first input of the first transaction is also called "coinbase" (its content was ignored in earlier versions)	| \<in-counter\>-many inputs|
|Out-counter	| positive integer VI = VarInt	| 1 - 9 bytes|
|list of outputs|	the outputs of the first transaction spend the mined bitcoins for the block	|\<out-counter\>-many outputs|
|lock_time	|if non-zero and sequence numbers are < 0xFFFFFFFF: block height or timestamp when transaction is final	|4 bytes|  

<br/>
为了确认自己理解了比特币交易的数据结构，最好的方式是自己写一个 parser, 然后使用自己写的这个 parser 去解析比特币交易数据的内容。我们可以使用任何自己熟悉的编程语言去写这个 parser, 但是在这篇文章中我会大部分使用 c 语言, 包括用 c 去写这个 parser, 因为我认为 c 语言是研究区块链技术最直接最方便的工具。

下面的实验中用到的文件 tx0.bin 可以从 [https://github.com/baya/block7days/blob/master/tx0.bin](https://github.com/baya/block7days/blob/master/tx0.bin) 下载或者通过 [webbtc](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b) 下载

### 1.1 解析 Version no

~~~c
/* parse_tx_version.c */

#include <stdio.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);

  printf("Tx Version: %u\n", tx_version);
}
~~~

通过分析 parse_tx_version.c 的代码我们可以看到用 c 语言解析比特币交易的数据结构非常直接: 定义一个 `unsigned int` 类型的 `tx_version` 变量, `tx_version`也是 4 bytes, 然后从 tx0.bin 的开始位置读 1 次, 读取的字节大小是 4 个字节, 这个 4 由 `sizeof(tx_version)` 计算出来, 读取的结果存放到 `tx_version` 变量里，编译上述代码,并执行,我们得到下面的输出:

~~~text
Tx Version: 1
~~~

### 1.2 解析 In-counter

参考: [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer](https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer)

`In-counter` 的结构定义如下:

**Variable length integer**

|Value	|Storage length	|Format|
|-------|---------------|------|
|< 0xFD	|1	|uint8\_t|
|<= 0xFFFF|	3	|0xFD followed by the length as uint16\_t|
|<= 0xFFFF FFFF	|5	|0xFE followed by the length as uint32\_t|
|-	|9	|0xFF followed by the length as uint64_t|

<br/>

解析的步骤如下:

* 读取第 1 个字节, 假设它的值为 `v1`

* 如果 `v1 < 0xF`, 那么 v1 就是 In-counter 的值

* 如果 `v1 == 0xFD`, 那么再读取 2 个字节, 这 2 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFE`, 那么再读取 4 个字节, 这 4 个字节存储的值即为 `In-counter` 的值

* 如果 `v1 == 0xFF`, 那么再读取 8 个字节, 这 8 个字节存储的值即为 `In-counter` 的值

~~~c

/* parse_tx_vinc.c */

#include <stdio.h>
#include <stdint.h>

int main()
{
  FILE *fp;
  unsigned int tx_version;

  
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fp = fopen("tx0.bin", "rb");
  fread(&tx_version, sizeof(tx_version), 1, fp);
  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %lld\n", tx_vin);
  
}

~~~

解析结果:

~~~text
Tx Version: 1
Tx In-counter: 1
~~~

### 1.3 解析 list of inputs


list of inputs 是由一组 Txin 构成的, Txin 的结构如下:

**general format (inside a block) of each input of a transaction - Txin**

|Field	|Description	|Size|
|-------|---------------|----|
|Previous Transaction hash|	doubled SHA256-hashed of a (previous) to-be-used transaction	|32 bytes|
|Previous Txout-index	|non negative integer indexing an output of the to-be-used transaction	|4 bytes|
|Txin-script length	|non negative integer VI = VarInt	|1 - 9 bytes|
|Txin-script / scriptSig	| Script	|\<in-script length\>-many bytes|
|sequence_no	|normally 0xFFFFFFFF; irrelevant unless transaction's lock_time is > 0	|4 bytes|

参考: [https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin](https://en.bitcoin.it/wiki/Transaction#general_format_.28inside_a_block.29_of_each_input_of_a_transaction_-_Txin)

为简单起见，我们只解析第一个 Txin, 我们以解析 Previous Transaction hash 为例子来讲讲解析过程。

1. Previous Transaction hash 一共有 32 个字节，为此我们定义一个长度为 32，类型为 `uint8_t` 的数组来存储 Hash, 这个数组定义为 `uint8_t pre_tx_hash[32];`

2. 将 Hash 以 16 进制的形式存储到一个字符串中, 这个字符串定义为 `char pre_tx_hash_str[65]`


parse_txin.c 的具体内容如下:

~~~c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sig(char *sig_str, uint64_t len, FILE *fp);

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;

  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  txin_sig = malloc(2*txin_script_len * sizeof(uint8_t) + 1);
  btc_sig(txin_sig, txin_script_len, fp);
  txin_seqno = btc_uint4(fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  printf("Txin-script / scriptSig: %s\n", txin_sig);
  printf("Txin sequence_no: %x\n", txin_seqno);
  

  fclose(fp);
  
}

void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  size_t ret_code = fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_sig(char *sig_str, uint64_t len, FILE *fp)
{
  uint8_t sig_buf[len];
  char buf3[3];
  
  size_t ret_code = fread(sig_buf, sizeof(uint8_t), len, fp);
  for(int64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2 + 1] = '\0';
  
}


~~~

因为 T0 的 Previous Transaction hash 是 "0000000000000000000000000000000000000000000000000000000000000000", 有一定的特殊性，为了
确认解析结果是否正确，我们可以解析其他一些不特殊的交易数据，比如 [https://webbtc.com/tx/703fc5...](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7), 编译代码后我们可以给程序提供一个待解析的交易文件名为参数，比如:

`$ ./a.out tx0.bin`

~~~bash
$ ./a.out tx0.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / scriptSig: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff

~~~

或者

`$ ./a.out tx_703fc5ee.bin`

~~~bash
$ ./a.out tx_703fc5ee.bin 
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
~~~

我们会发现解析 tx_703fc5ee.bin 的结果中 scriptSig 和 [https://webbtc.com/tx/703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 scriptSig 有些不一样, 一眼可以看出我们自己解析出的 scriptSig 前面多了 47, 这是什么原因导致的呢？回头再看 Txin 的结构表, Txin-script / scriptSig 的描述是一个 [Script(https://en.bitcoin.it/wiki/Script)](https://en.bitcoin.it/wiki/Script), 比特币的 [Script](https://en.bitcoin.it/wiki/Script) 是一个类似 [Forth](http://en.wikipedia.org/wiki/FORTH) 语言的东西，我们自己写的解析器已经可以将 Script 的内容原原本本地读出来了，但是还需要将它翻译下。

[703fc5ee.json](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 中的 txin 的 scriptSig 的内容如下:

~~~text
scriptSig: "304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

我们自己写的解析器解析 tx_703fc5ee.bin 得到的 scriptSig 的内容如下：

~~~text
scriptSig: "47304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c880121030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc"
~~~

到目前为止, 我们的主要目的是解析 T0 的数据结构, 同时我们又通过解析文件 tx_703fc5ee.bin 来做一个参考检验, 我们会先把主要的精力放在解析 tx0.bin 和 tx_703fc5ee.bin 上面，所以在这篇文章中，我们后续的解析工作会继续围绕在 tx0.bin 和 tx_703fc5ee.bin 这两个文件上面, 代码的编写也会主要针对这两个文件。


### 1.4 解析 Txin-script / scriptSig

在这一节中我们将主要讨论解析 tx_703fc5ee.bin 和 tx0.bin 这两个文件的 Txin-script / scriptSig, 其中 tx0.bin 的 Txin-script / scriptSig 的更准确的名字应该是 coinbase.

scriptSig 的结构是: `<Signature> <PubKey>`, 也就是说 scriptSig 分为两部分：第 1 部分是 Signature, 第 2 部分是 PubKey, 那么我们如何将文件 tx_703fc5ee.bin 的 scriptSig 解析成 Signature 和 PubKey 两部分呢?

首先我们看一个表:

[Constants](https://en.bitcoin.it/wiki/Script#Constants)

When talking about scripts, these value-pushing words are usually omitted.

|Word	|Opcode	|Hex	|Input	|Output	|Description|
|-------|-------|-------|-------|-------|-----------|
|OP\_0, OP\_FALSE	|0	    |0x00	|Nothing.|	(empty value)	|An empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)
|N/A	|1-75	|0x01-0x4b	|(special)	|data	|The next opcode bytes is data to be pushed onto the stack|
|OP\_PUSHDATA1	|76	|0x4c	|(special)	|data	|The next byte contains the number of bytes to be pushed onto the stack.|
|OP\_PUSHDATA2	|77	|0x4d	|(special)	|data	|The next two bytes contain the number of bytes to be pushed onto the stack.
|OP\_PUSHDATA4	|78	|0x4e	|(special)	|data	|The next four bytes contain the number of bytes to be pushed onto the stack.
|OP\_1NEGATE	|79	|0x4f	|Nothing.	|-1	    |The number -1 is pushed onto the stack.
|OP\_1, OP\_TRUE|	81	|0x51	|Nothing.|	1	|The number 1 is pushed onto the stack.
|OP\_2-OP\_16	|82-96	|0x52-0x60	|Nothing.	|2-16	The number in the word name (2-16) is pushed onto the stack.

<br/>

为简单起见，我们先只分析 Opcode 为 1-75 的情况, 当 `1 <= Opcode <= 75` 时, Opcode 后面的 Opcode 个字节的数据将被压入到栈中，这个会被压入到栈中的数据就是 Signature 或者 PubKey, 这里的栈是比特币脚本系统的一种数据结构，用于运行 Script.

通过下面的图我们可以更加直观地理解 scriptSig.

![sig-pubkey](/images/sig-pubkey-parse.png)

通过上图我们已经可以手工地解析出 Signature 和 PubKey, 接下来我们通过编写代码来实现解析。

parse_txin_script_sig.c 的内容如下: 

~~~c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"

#define OP_FALSE           0x00
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define OP_PUSHDATA1       0x4c
#define OP_PUSHDATA2       0x4d
#define OP_PUSHDATA4       0x4e
#define OP_1NEGATE         0x4f
#define OP_TRUE            0x51
#define OP_2               0x52
#define OP_3               0x53
#define OP_4               0x54
#define OP_5               0x55
#define OP_6               0x56
#define OP_7               0x57
#define OP_8               0x58
#define OP_9               0x59
#define OP_10              0x5a
#define OP_11              0x5b
#define OP_12              0x5c
#define OP_13              0x5d
#define OP_14              0x5e
#define OP_15              0x5f
#define OP_16              0x60

#define SIG_BUF_SIZE       1000

typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;


uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sc_sig(script_sig *sig_ptr, FILE *fp);
void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], const uint64_t len);
void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp);
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp);

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;
  script_sig sc_sig;
  coinbase_sig cb_sig;

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }

  txin_seqno = btc_uint4(fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  if(cb_sig.len > 0){
    printf("Txin-script / coinbase: %s\n", cb_sig.sig);
  }
  if(sc_sig.len > 0){
    printf("Txin-script / scriptSig: %s %s\n", sc_sig.sig, sc_sig.pubkey);
  }
  printf("Txin sequence_no: %x\n", txin_seqno);
  

  fclose(fp);
  
}


void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
  } else {
  }

}


void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp)
{
  uint8_t *sig_buf;
  
  sig_buf = malloc(op_code * sizeof(uint8_t));
  fread(sig_buf, sizeof(uint8_t), op_code, fp);
  cp_sig_hex_to_str(str, sig_buf, op_code);

  free(sig_buf);
}


void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], uint64_t len)
{
  char buf3[3];
  for(int64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2] = '\0';
}

~~~

编译文件 parse_txin_script_sig.c, 然后分别使用 tx0.bin 和 tx_703fc5ee.bin 作为输入文件进行测试，测试结果如下:

~~~bash
$ ./a.out tx0.bin 

Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
~~~

~~~bash
$ ./a.out tx_703fc5ee.bin 

Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
~~~

将上面的测试结果分别与 webbtc.com 上的 [TX-0](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b.json) 和 [TX-703fc5ee](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json)
作比较，我们会发现结果是吻合的。

解析的过程是这样的，首先定义了一系列的宏, 我们只列出用到的宏进行叙述:

~~~c
#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define SIG_BUF_SIZE       1000
~~~

`COINBASE_INX` 和 `NULL_HASH` 结合起来使用，用于判断 Txin(交易输入) 是否是 coinbase 类型的输入, 什么是 coinbase 呢? 简单地说就是比特币系统给你输入了一笔钱，这笔钱不是来自任何的个人。如果一个 Txin 的 Previous Txout-index 等于 `COINBASE_INX` 并且 Previous Tx Hash 等于 `NULL_HASH`, 那么这个 Txin 就是 coinbase 类型的输入.

`OP_PUSHDATA0_START` 和 `OP_PUSHDATA0_END` 结合起来使用，用于解析下面的规则:

|Word	|Opcode	|Hex	|Input	|Output	|Description|
|-------|-------|-------|-------|-------|-----------|
|N/A	|1-75	|0x01-0x4b	|(special)	|data	|The next opcode bytes is data to be pushed onto the stack|

<br/>
对于一个非 coinbase 类型的 Txin, 当读取它的 scriptSig 时, 如果 opcode 的值是在 `OP_PUSHDATA0_START` 和 `OP_PUSHDATA0_END` 之间就需要使用上述的规则解析 scriptSig.

`SIG_BUF_SIZE` 用于给 coinbase 和 scriptSig 固定分配一段足够大的内存，因为 coinbase 和 scriptSig 是变长的，如果在程序运行时动态分配内存会是一件比较复杂的事情，所以我们预先设定 `SIG_BUF_SIZE` 为 1000 个字节，足够容纳 coinbase 或者 scriptSig.

然后我们定义 coinbase 和 scriptSig 的数据结构:

~~~c
typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;
~~~

我们用 `struct coinbase_sig` 来存储 coinbase, 用 `struct script_sig` 来存储 scriptSig.

接着定义用于解析 coinbase 和 scriptSig 的函数:

~~~c
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
  } else {
  }

}
~~~

其中 `void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)` 用于解析 coinbase, `void btc_sc_sig(script_sig *sig_ptr, FILE *fp)` 用于解析 scriptSig.

最后实际的解析过程如下, 去掉了一些不相关的代码，

~~~c

  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  script_sig sc_sig;
  coinbase_sig cb_sig;

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }
  
~~~

### 1.5 解析 Txout

Txout 的格式如下:

|Field	|Description	|Size|
|-------|---------------|----|
|value	|non negative integer giving the number of Satoshis(BTC/10^8) to be transfered|	8 bytes|
|Txout-script length	|non negative integer	|1 - 9 bytes VI = VarInt|
|Txout-script / scriptPubKey	|Script	|\<out-script length\>-many bytes|

<br/>


文件 parse_txout.c 内容:

~~~c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"

#define OP_FALSE           0x00
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define OP_PUSHDATA1       0x4c
#define OP_PUSHDATA2       0x4d
#define OP_PUSHDATA4       0x4e
#define OP_1NEGATE         0x4f
#define OP_TRUE            0x51
#define OP_2               0x52
#define OP_3               0x53
#define OP_4               0x54
#define OP_5               0x55
#define OP_6               0x56
#define OP_7               0x57
#define OP_8               0x58
#define OP_9               0x59
#define OP_10              0x5a
#define OP_11              0x5b
#define OP_12              0x5c
#define OP_13              0x5d
#define OP_14              0x5e
#define OP_15              0x5f
#define OP_16              0x60

#define SIG_BUF_SIZE       1000

typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;

typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
} tx_out;



uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sc_sig(script_sig *sig_ptr, FILE *fp);
void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], const uint64_t len);
void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp);
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp);
tx_out *read_tx_out_list(uint64_t count, FILE *fp);
uint8_t btc_uint1(FILE *fp);
uint64_t btc_uint8(FILE *fp);
char *btc_sc_pbk(uint64_t len, FILE *fp);

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;
  script_sig sc_sig;
  coinbase_sig cb_sig;
  uint64_t tx_vout;
  tx_out *txo_list;
  

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }

  txin_seqno = btc_uint4(fp);
  tx_vout = btc_varint(fp);

  txo_list = read_tx_out_list(tx_vout, fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  if(cb_sig.len > 0){
    printf("Txin-script / coinbase: %s\n", cb_sig.sig);
  }
  if(sc_sig.len > 0){
    printf("Txin-script / scriptSig: %s %s\n", sc_sig.sig, sc_sig.pubkey);
  }
  printf("Txin sequence_no: %x\n", txin_seqno);

  printf("Txout Out-counter: %llu\n", tx_vout);
  for(int i=0; i < tx_vout; i++){
    printf("Txout Value: %llu\n", txo_list[i].value);
    printf("Txout-script length: %llu\n", txo_list[i].len);
    printf("Txout-script / scriptPubkey: %s\n", txo_list[i].sc_pbk);
  }
  

  fclose(fp);
  
}

tx_out *read_tx_out_list(uint64_t count, FILE *fp)
{
  tx_out *txo_list;
  uint64_t tmp;

  txo_list = (tx_out*) malloc(count * sizeof(tx_out));
  for(uint64_t i=0; i < count; i++){
    txo_list[i].value = btc_uint8(fp);
    tmp = btc_varint(fp);
    txo_list[i].len = tmp;
    txo_list[i].sc_pbk = btc_sc_pbk(txo_list[i].len, fp);
  }

  return txo_list;
}

char *btc_sc_pbk(uint64_t len, FILE *fp)
{
  char *sc_pbk;
  uint8_t *buf;
  sc_pbk = (char *) malloc((2 * len + 1) * sizeof(char));
  buf = (uint8_t *) malloc(len * sizeof(uint8_t));
  fread(buf, sizeof(uint8_t), len, fp);
  cp_sig_hex_to_str(sc_pbk, buf, len);

  return sc_pbk;
}

uint64_t btc_uint8(FILE *fp)
{
  uint64_t buf;
  fread(&buf, sizeof(buf), 1, fp);
  return buf;
}

uint8_t btc_uint1(FILE *fp)
{
  uint8_t buf;
  fread(&buf, sizeof(buf), 1, fp);
  return buf;
}


void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
  } else {
  }

}


void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp)
{
  uint8_t *sig_buf;
  
  sig_buf = malloc(op_code * sizeof(uint8_t));
  fread(sig_buf, sizeof(uint8_t), op_code, fp);
  cp_sig_hex_to_str(str, sig_buf, op_code);

  free(sig_buf);
}


void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], uint64_t len)
{
  char buf3[3];
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2] = '\0';
}

~~~

解析的过程大致如下:

1\. 定义 Txout 的数据结构

~~~c
typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
} tx_out;
~~~

Txout 的 value 的 size 是 8 bytes，所以用一个 uint64_t 类型的变量存储 value。

Txout 的 script length 是一个 1-9 bytes 的 VarInt(即可变长整型), 取最大长度，我们用一个 uint64_t 类型的变量存储 script length。 

使用字符指针指向我们将来要解析出的 scriptPubKey .

2\. 定义用于读取 Txout 的函数

~~~c

tx_out *read_tx_out_list(uint64_t count, FILE *fp)
{
  tx_out *txo_list;
  uint64_t tmp;

  txo_list = (tx_out*) malloc(count * sizeof(tx_out));
  for(uint64_t i=0; i < count; i++){
    txo_list[i].value = btc_uint8(fp);
    tmp = btc_varint(fp);
    txo_list[i].len = tmp;
    txo_list[i].sc_pbk = btc_sc_pbk(txo_list[i].len, fp);
  }

  return txo_list;
}

char *btc_sc_pbk(uint64_t len, FILE *fp)
{
  char *sc_pbk;
  uint8_t *buf;
  sc_pbk = (char *) malloc((2 * len + 1) * sizeof(char));
  buf = (uint8_t *) malloc(len * sizeof(uint8_t));
  fread(buf, sizeof(uint8_t), len, fp);
  cp_sig_hex_to_str(sc_pbk, buf, len);

  return sc_pbk;
}

~~~

3\. 读取和打印 Txout

~~~c

  txo_list = read_tx_out_list(tx_vout, fp);

  for(int i=0; i < tx_vout; i++){
    printf("Txout Value: %llu\n", txo_list[i].value);
    printf("Txout-script length: %llu\n", txo_list[i].len);
    printf("Txout-script / scriptPubkey: %s\n", txo_list[i].sc_pbk);
  }
~~~

其中 `tx_vout` 存储的是 Txout 的 count 值.

调试结果:

`$ ./a.out tx0.bin` 得到输出:

~~~bash
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
Txout Out-counter: 1
Txout Value: 5000000000
Txout-script length: 67
Txout-script / scriptPubkey: 4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac
~~~

`$ ./a.out tx_703fc5ee.bin` 得到输出:

~~~bash
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
Txout Out-counter: 2
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914a31e71f2cfc0327c55cc4026073f06f3e9e1a21a88ac
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914d6bbf4f08d2df7ea32b2930ae4b7436d4ca6fe4b88ac
~~~

Txout Value 以 [Satoshis(BTC/10^8)](https://en.bitcoin.it/wiki/FAQ#What_do_I_call_the_various_denominations_of_bitcoins.3F) 为单位.

现在读取出的 scriptPubkey 是原始的值，在 1.6 节中将解析 scriptPubkey.

### 1.6 解析 Txout-script / scriptPubKey

以 tx_703fc5ee.bin 中的 scriptPubkey 为例子，我们首先人肉翻译 scriptPubKey, 翻译过程如下图所示:

![parse sc pubkey](/images/parse_sc_pubk.jpg)

文件 parse_txout_script_pbk.c 的内容:

```c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define COINBASE_INX       0xffffffff
#define NULL_HASH          "0000000000000000000000000000000000000000000000000000000000000000"

/* Constants */
#define OP_FALSE           0x00
#define OP_PUSHDATA0_START 0x01
#define OP_PUSHDATA0_END   0x4b
#define OP_PUSHDATA1       0x4c
#define OP_PUSHDATA2       0x4d
#define OP_PUSHDATA4       0x4e
#define OP_1NEGATE         0x4f
#define OP_TRUE            0x51
#define OP_2               0x52
#define OP_3               0x53
#define OP_4               0x54
#define OP_5               0x55
#define OP_6               0x56
#define OP_7               0x57
#define OP_8               0x58
#define OP_9               0x59
#define OP_10              0x5a
#define OP_11              0x5b
#define OP_12              0x5c
#define OP_13              0x5d
#define OP_14              0x5e
#define OP_15              0x5f
#define OP_16              0x60

/* Flow control */
#define OP_NOP    0x61
#define OP_IF     0x63
#define OP_NOTIF  0x64
#define OP_ELSE   0x67
#define OP_ENDIF  0x68
#define OP_VERIFY 0x69
#define OP_RETURN 0x6a

/* Stack */
#define OP_TOALTSTACK   0x6b
#define OP_FROMALTSTACK 0x6c
#define OP_IFDUP        0x73
#define OP_DEPTH        0x74
#define OP_DROP         0x75
#define OP_DUP          0x76
#define OP_NIP          0x77
#define OP_OVER         0x78
#define OP_PICK         0x79
#define OP_ROLL         0x7a
#define OP_ROT          0x7b
#define OP_SWAP         0x7c
#define OP_TUCK         0x7d
#define OP_2DROP        0x6d
#define OP_2DUP         0x6e
#define OP_3DUP         0x6f
#define OP_2OVER        0x70
#define OP_2ROT         0x71
#define OP_2SWAP        0x72

/* Splice */
#define OP_CAT    0x7e
#define OP_SUBSTR 0x7f
#define OP_LEFT   0x80
#define OP_RIGHT  0x81
#define OP_SIZE   0x82

/* Bitwise logic */
#define OP_INVERT      0x83
#define OP_AND         0x84
#define OP_OR          0x85
#define OP_XOR         0x86
#define OP_EQUAL       0x87
#define OP_EQUALVERIFY 0x88

/* Arithmetic */
#define OP_1ADD               0x8b
#define OP_1SUB               0x8c
#define OP_2MUL               0x8d
#define OP_2DIV               0x8e
#define OP_NEGATE             0x8f
#define OP_ABS                0x90
#define OP_NOT                0x91
#define OP_0NOTEQUAL          0x92
#define OP_ADD                0x93
#define OP_SUB                0x94
#define OP_MUL                0x95
#define OP_DIV                0x96
#define OP_MOD                0x97
#define OP_LSHIFT             0x98
#define OP_RSHIFT             0x99
#define OP_BOOLAND            0x9a
#define OP_BOOLOR             0x9b
#define OP_NUMEQUAL           0x9c
#define OP_NUMEQUALVERIFY     0x9d
#define OP_NUMNOTEQUAL        0x9e
#define OP_LESSTHAN           0x9f
#define OP_GREATERTHAN        0xa0
#define OP_LESSTHANOREQUAL    0xa1
#define OP_GREATERTHANOREQUAL 0xa2
#define OP_MIN                0xa3
#define OP_MAX                0xa4
#define OP_WITHIN             0xa5

/* Crypto */
#define OP_RIPEMD160           0xa6
#define OP_SHA1                0xa7
#define OP_SHA256              0xa8
#define OP_HASH160             0xa9
#define OP_HASH256             0xaa
#define OP_CODESEPARATOR       0xab
#define OP_CHECKSIG            0xac
#define OP_CHECKSIGVERIFY      0xad
#define OP_CHECKMULTISIG       0xae
#define OP_CHECKMULTISIGVERIFY 0xaf

/* Locktime */
#define OP_CHECKLOCKTIMEVERIFY 0xb1
#define OP_CHECKSEQUENCEVERIFY 0xb2

/* Pseudo-words */
#define OP_PUBKEYHASH    0xfd
#define OP_PUBKEY        0xfe
#define OP_INVALIDOPCODE 0xff

/* Reserved words */
#define OP_RESERVED  0x50
#define OP_VER       0x62
#define OP_VERIF     0x65
#define OP_VERNOTIF  0x66
#define OP_RESERVED1 0x89
#define OP_RESERVED2 0x8a
#define OP_NOP1      0xb0
#define OP_NOP9      0xb9

#define NO_FOUND_OPTCODE "NO_FOUND_OPTCODE"

#define SIG_BUF_SIZE 1000
#define PBK_STACK_SIZE 1000

typedef struct coinbase_sig {
  char sig[SIG_BUF_SIZE];
  uint64_t len;
} coinbase_sig;

typedef struct script_sig {
  char sig[SIG_BUF_SIZE];
  char pubkey[SIG_BUF_SIZE];
  uint64_t len;
} script_sig;

typedef struct script_pbk {
  char *stack[PBK_STACK_SIZE];
} script_pbk;

typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
  script_pbk *parsed_sc_pbk;
} tx_out;



uint32_t btc_uint4(FILE *fp);
void get_hex2_str(char *buf, const uint8_t b);
uint64_t btc_varint(FILE *fp);
void btc_hash(char *tx_hash_str, FILE *fp);
void btc_sc_sig(script_sig *sig_ptr, FILE *fp);
void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], const uint64_t len);
void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp);
void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp);
tx_out *read_tx_out_list(uint64_t count, FILE *fp);
uint8_t btc_uint1(FILE *fp);
uint64_t btc_uint8(FILE *fp);
char *btc_sc_pbk(uint64_t len, FILE *fp);
script_pbk *btc_parsed_sc_pbk(uint64_t len, FILE *fp);
void print_parsed_sc_pbk(script_pbk *sc_pbk);
char *tr_opcode_to_name(uint8_t opcode);
int is_sc_na_constant(uint8_t opcode);

/* generated by parse_script_optcode_to_c_array.rb */
static char *btc_sc_opcode_names[] = {"OP_FALSE","OP_PUSHDATA0_START","OP_PUSHDATA0_END","OP_PUSHDATA1","OP_PUSHDATA2","OP_PUSHDATA4","OP_1NEGATE",
				      "OP_TRUE","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15",
				      "OP_16","OP_NOP","OP_IF","OP_NOTIF","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK",
				      "OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","OP_ROT","OP_SWAP","OP_TUCK","OP_2DROP",
				      "OP_2DUP","OP_3DUP","OP_2OVER","OP_2ROT","OP_2SWAP","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_SIZE","OP_INVERT",
				      "OP_AND","OP_OR","OP_XOR","OP_EQUAL","OP_EQUALVERIFY","OP_1ADD","OP_1SUB","OP_2MUL","OP_2DIV","OP_NEGATE","OP_ABS",
				      "OP_NOT","OP_0NOTEQUAL","OP_ADD","OP_SUB","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_BOOLAND","OP_BOOLOR",
				      "OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL",
				      "OP_MIN","OP_MAX","OP_WITHIN","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CODESEPARATOR","OP_CHECKSIG",
				      "OP_CHECKSIGVERIFY","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","OP_CHECKLOCKTIMEVERIFY","OP_CHECKSEQUENCEVERIFY","OP_PUBKEYHASH",
				      "OP_PUBKEY","OP_INVALIDOPCODE","OP_RESERVED","OP_VER","OP_VERIF","OP_VERNOTIF","OP_RESERVED1","OP_RESERVED2","OP_NOP1","OP_NOP9"};

/* generated by parse_script_optcode_to_c_array.rb */
static uint8_t btc_sc_opcodes[] = {0x00,0x01,0x4b,0x4c,0x4d,0x4e,0x4f,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
				   0x60,0x61,0x63,0x64,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x6d,
				   0x6e,0x6f,0x70,0x71,0x72,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
				   0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,
				   0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb1,0xb2,0xfd,0xfe,0xff,0x50,0x62,0x65,0x66,0x89,0x8a,0xb0,0xb9};

int main(int argc, char *argv[])
{
  FILE *fp;
  uint32_t tx_version;
  uint64_t tx_vin;
  uint32_t pre_txout_inx;
  char pre_tx_hash_str[65];
  uint64_t txin_script_len;
  char *txin_sig;
  uint32_t txin_seqno;
  script_sig sc_sig;
  coinbase_sig cb_sig;
  uint64_t tx_vout;
  tx_out *txo_list;
  uint32_t lock_time;
  

  sc_sig.len = 0;
  cb_sig.len = 0;
  
  fp = fopen(argv[1], "rb");
  tx_version = btc_uint4(fp);
  tx_vin = btc_varint(fp);
  btc_hash(pre_tx_hash_str, fp);
  pre_txout_inx = btc_uint4(fp);
  txin_script_len = btc_varint(fp);
  if(pre_txout_inx == COINBASE_INX && strcmp(pre_tx_hash_str, NULL_HASH) == 0){
    cb_sig.len = txin_script_len;
    btc_cb_sig(&cb_sig, fp);
  } else {
    sc_sig.len = txin_script_len;
    btc_sc_sig(&sc_sig, fp);
  }

  txin_seqno = btc_uint4(fp);
  tx_vout = btc_varint(fp);

  txo_list = read_tx_out_list(tx_vout, fp);
  lock_time = btc_uint4(fp);

  printf("Tx Version: %u\n", tx_version);
  printf("Tx In-counter: %llu\n", tx_vin);
  printf("Txin Previous Tx Hash: %s\n", pre_tx_hash_str);
  printf("Txin Previous Txout-index: %x\n", pre_txout_inx);
  printf("Txin-script length: %llu\n", txin_script_len);
  if(cb_sig.len > 0){
    printf("Txin-script / coinbase: %s\n", cb_sig.sig);
  }
  if(sc_sig.len > 0){
    printf("Txin-script / scriptSig: %s %s\n", sc_sig.sig, sc_sig.pubkey);
  }
  printf("Txin sequence_no: %x\n", txin_seqno);

  printf("Txout Out-counter: %llu\n", tx_vout);
  for(int i=0; i < tx_vout; i++){
    printf("Txout Value: %llu\n", txo_list[i].value);
    printf("Txout-script length: %llu\n", txo_list[i].len);
    printf("Txout-script / scriptPubkey: %s\n", txo_list[i].sc_pbk);
    print_parsed_sc_pbk(txo_list[i].parsed_sc_pbk);
  }
  printf("Tx Lock Time: %x\n", lock_time);
  

  fclose(fp);
  
}


tx_out *read_tx_out_list(uint64_t count, FILE *fp)
{
  tx_out *txo_list;
  uint64_t tmp;

  txo_list = (tx_out*) malloc(count * sizeof(tx_out));
  for(uint64_t i=0; i < count; i++){
    txo_list[i].value = btc_uint8(fp);
    tmp = btc_varint(fp);
    txo_list[i].len = tmp;
    txo_list[i].sc_pbk = btc_sc_pbk(txo_list[i].len, fp);
    fseek(fp, -txo_list[i].len, SEEK_CUR);
    txo_list[i].parsed_sc_pbk = btc_parsed_sc_pbk(txo_list[i].len, fp);
  }

  return txo_list;
}

script_pbk *btc_parsed_sc_pbk(uint64_t len, FILE *fp)
{
  script_pbk *sc_pbk_ptr = malloc(sizeof(script_pbk));
  char **stack_ptr;
  uint64_t i = 0;
  uint8_t opcode;

  stack_ptr = sc_pbk_ptr -> stack;
  do {
    opcode = btc_uint1(fp);
    i += 1;
    if(is_sc_na_constant(opcode)){
      *stack_ptr = (char *)malloc((2 * opcode + 1) * sizeof(char));
      read_op_pushdata0(*stack_ptr, opcode, fp);
      i += opcode;
    } else {
      *stack_ptr = tr_opcode_to_name(opcode);
    }
    stack_ptr++;

  } while(i < len);


  return sc_pbk_ptr;
}

void print_parsed_sc_pbk(script_pbk *sc_pbk)
{
  char **stack_ptr = sc_pbk -> stack;
  printf("Txout-script / Parsed scriptPubkey: ");
  do{
    printf("%s ", *stack_ptr);
    stack_ptr++;
  } while(*stack_ptr);

  printf("\n");
}

int is_sc_na_constant(uint8_t opcode)
{
  if(opcode >= OP_PUSHDATA0_START && opcode <= OP_PUSHDATA0_END){
    return 1;
  } else {
    return 0;
  }
}

char *tr_opcode_to_name(uint8_t opcode)
{
  int i;
  char *res;
  size_t n = sizeof(btc_sc_opcodes) / sizeof(btc_sc_opcodes[0]);
  for(i = 0; i < n; i++)
  {
    if(btc_sc_opcodes[i] == opcode){
      break;
    }
  }

  if(i < n){
    res = btc_sc_opcode_names[i];
  } else {
    res = NO_FOUND_OPTCODE;
  }

  return res;
}

char *btc_sc_pbk(uint64_t len, FILE *fp)
{
  char *sc_pbk;
  uint8_t *buf;
  sc_pbk = (char *) malloc((2 * len + 1) * sizeof(char));
  buf = (uint8_t *) malloc(len * sizeof(uint8_t));
  fread(buf, sizeof(uint8_t), len, fp);
  cp_sig_hex_to_str(sc_pbk, buf, len);

  return sc_pbk;
}

uint64_t btc_uint8(FILE *fp)
{
  uint64_t buf;
  fread(&buf, sizeof(buf), 1, fp);
  return buf;
}

uint8_t btc_uint1(FILE *fp)
{
  uint8_t buf;
  fread(&buf, sizeof(buf), 1, fp);
  return buf;
}


void get_hex2_str(char *buf, const uint8_t b)
{
  snprintf(buf, 3, "%02x", b);
}

uint32_t btc_uint4(FILE *fp)
{
  uint32_t buf;
  fread(&buf, sizeof(buf), 1, fp);

  return buf;
}

uint64_t btc_varint(FILE *fp)
{
  uint8_t  tx_vin1;
  uint16_t tx_vin2;
  uint32_t tx_vin4;
  uint64_t tx_vin8;
  uint64_t tx_vin;

  fread(&tx_vin1, sizeof(tx_vin1), 1, fp);
  if(tx_vin1 < 0xFD){
    tx_vin = tx_vin1;
  } else if(tx_vin1 == 0xFD){
    fread(&tx_vin2, sizeof(tx_vin2), 1, fp);
    tx_vin = tx_vin2;
  } else if(tx_vin1 == 0xFE) {
    fread(&tx_vin4, sizeof(tx_vin4), 1, fp);
    tx_vin = tx_vin4;
  } else if(tx_vin1 == 0xFF) {
    fread(&tx_vin8, sizeof(tx_vin8), 1, fp);
    tx_vin = tx_vin8;
  } else {
    tx_vin = 0;
  }

  return tx_vin;
}

void btc_hash(char *tx_hash_str, FILE *fp)
{
  uint8_t tx_hash[32];
  char buf3[3];

  fread(tx_hash, sizeof(uint8_t), 32, fp);
  for(int i=31; i >=0; --i)
  {
    get_hex2_str(buf3, tx_hash[i]);
    tx_hash_str[(31-i) *2] = buf3[0];
    tx_hash_str[(31-i) *2 + 1] = buf3[1];
    if(i == 0){
      tx_hash_str[64] = '\0';
    }
  }
}

void btc_cb_sig(coinbase_sig *sig_ptr, FILE *fp)
{
  uint64_t len = sig_ptr -> len;
  uint8_t sig_buf[len];
  char buf3[3];
  
  fread(sig_buf, sizeof(uint8_t), len, fp);
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_ptr->sig[i * 2] = buf3[0];
    sig_ptr->sig[i * 2 + 1] = buf3[1];
  }

  sig_ptr->sig[len * 2] = '\0';

}

void btc_sc_sig(script_sig *sig_ptr, FILE *fp)
{
  uint8_t op_code;
  uint64_t len = 1;
  
  char buf3[3];

  fread(&op_code, sizeof(uint8_t), 1, fp);
  if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
    len += op_code;
    read_op_pushdata0(sig_ptr -> sig, op_code, fp);
  } else {
  }

  if(len < sig_ptr->len){
    fread(&op_code, sizeof(uint8_t), 1, fp);
    if(op_code >= OP_PUSHDATA0_START && op_code <= OP_PUSHDATA0_END){
      len += op_code;
      read_op_pushdata0(sig_ptr -> pubkey, op_code, fp);
    } else {
    }
  }

}


void read_op_pushdata0(char *str, uint8_t op_code, FILE *fp)
{
  uint8_t *sig_buf;
  sig_buf = (uint8_t *) malloc(op_code * sizeof(sig_buf));
  fread(sig_buf, sizeof(uint8_t), op_code, fp);
  cp_sig_hex_to_str(str, sig_buf, op_code);

  free(sig_buf);
}


void cp_sig_hex_to_str(char *sig_str, const uint8_t sig_buf[], uint64_t len)
{
  char buf3[3];
  for(uint64_t i=0; i < len; i++)
  {
    get_hex2_str(buf3, sig_buf[i]);
    sig_str[i * 2] = buf3[0];
    sig_str[i * 2 + 1] = buf3[1];
  }

  sig_str[len * 2] = '\0';
}


```

解析的过程大致如下:

1\. 定义和 opcode 相关的宏，可以在文件 parse_txout_script_pbk.c 中查看所有已经定义好的 opcode 宏

2\. 定义 scriptPubkey 的数据结构, 并且将 scriptPubkey 与 Txout 关联

```c
#define PBK_STACK_SIZE 50

typedef struct script_pbk {
  char *stack[PBK_STACK_SIZE];
} script_pbk;

typedef struct tx_out {
  uint64_t value;
  uint64_t len;
  char *sc_pbk;
  script_pbk *parsed_sc_pbk;
} tx_out;

```

我们通过 `script_pbk *parsed_sc_pbk;` 将 scriptPubkey 和 Txout 关联起来

3\. 定义用于把 opcode 转换为 opcode name 的索引变量.

```c
static char *btc_sc_opcode_names[] = {"OP_FALSE","OP_PUSHDATA0_START","OP_PUSHDATA0_END","OP_PUSHDATA1","OP_PUSHDATA2","OP_PUSHDATA4","OP_1NEGATE",
				      "OP_TRUE","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15",
				      "OP_16","OP_NOP","OP_IF","OP_NOTIF","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK",
				      "OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","OP_ROT","OP_SWAP","OP_TUCK","OP_2DROP",
				      "OP_2DUP","OP_3DUP","OP_2OVER","OP_2ROT","OP_2SWAP","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_SIZE","OP_INVERT",
				      "OP_AND","OP_OR","OP_XOR","OP_EQUAL","OP_EQUALVERIFY","OP_1ADD","OP_1SUB","OP_2MUL","OP_2DIV","OP_NEGATE","OP_ABS",
				      "OP_NOT","OP_0NOTEQUAL","OP_ADD","OP_SUB","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_BOOLAND","OP_BOOLOR",
				      "OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL",
				      "OP_MIN","OP_MAX","OP_WITHIN","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CODESEPARATOR","OP_CHECKSIG",
				      "OP_CHECKSIGVERIFY","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","OP_CHECKLOCKTIMEVERIFY","OP_CHECKSEQUENCEVERIFY","OP_PUBKEYHASH",
				      "OP_PUBKEY","OP_INVALIDOPCODE","OP_RESERVED","OP_VER","OP_VERIF","OP_VERNOTIF","OP_RESERVED1","OP_RESERVED2","OP_NOP1","OP_NOP9"};

/* generated by parse_script_optcode_to_c_array.rb */
static uint8_t btc_sc_opcodes[] = {0x00,0x01,0x4b,0x4c,0x4d,0x4e,0x4f,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
				   0x60,0x61,0x63,0x64,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x6d,
				   0x6e,0x6f,0x70,0x71,0x72,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,
				   0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,
				   0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb1,0xb2,0xfd,0xfe,0xff,0x50,0x62,0x65,0x66,0x89,0x8a,0xb0,0xb9};

```

4\. 实现解析 scriptPubkey 的函数

```c
script_pbk *btc_parsed_sc_pbk(uint64_t len, FILE *fp)
{
  script_pbk *sc_pbk_ptr = malloc(sizeof(script_pbk));
  char **stack_ptr;
  uint64_t i = 0;
  uint8_t opcode;

  stack_ptr = sc_pbk_ptr -> stack;
  do {
    opcode = btc_uint1(fp);
    i += 1;
    if(is_sc_na_constant(opcode)){
      *stack_ptr = (char *)malloc((2 * opcode + 1) * sizeof(char));
      read_op_pushdata0(*stack_ptr, opcode, fp);
      i += opcode;
    } else {
      *stack_ptr = tr_opcode_to_name(opcode);
    }
    ++stack_ptr;
    
  } while(i < len);


  return sc_pbk_ptr;
}

void print_parsed_sc_pbk(script_pbk *sc_pbk)
{
  char **stack_ptr = sc_pbk -> stack;
  printf("Txout-script / Parsed scriptPubkey: ");
  do{
    printf("%s ", *stack_ptr);
    stack_ptr++;
  } while(*stack_ptr);

  printf("\n");
}

int is_sc_na_constant(uint8_t opcode)
{
  if(opcode >= OP_PUSHDATA0_START && opcode <= OP_PUSHDATA0_END){
    return 1;
  } else {
    return 0;
  }
}

char *tr_opcode_to_name(uint8_t opcode)
{
  int i;
  char *res;
  size_t n = sizeof(btc_sc_opcodes) / sizeof(btc_sc_opcodes[0]);
  for(i = 0; i < n; i++)
  {
    if(btc_sc_opcodes[i] == opcode){
      break;
    }
  }

  if(i < n){
    res = btc_sc_opcode_names[i];
  } else {
    res = NO_FOUND_OPTCODE;
  }

  return res;
}

```

我们将解析出来的 scriptPubkey 存储到 `parsed_sc_pbk` 中, 

```c
txo_list[i].parsed_sc_pbk = btc_parsed_sc_pbk(txo_list[i].len, fp);
```

`parsed_sc_pbk` 其实是一个指针变量，我们用它指向 scriptPubkey 所存储的地址.

调试的结果如下:

`$ ./a.out tx0.bin`

```
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: 0000000000000000000000000000000000000000000000000000000000000000
Txin Previous Txout-index: ffffffff
Txin-script length: 77
Txin-script / coinbase: 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
Txin sequence_no: ffffffff
Txout Out-counter: 1
Txout Value: 5000000000
Txout-script length: 67
Txout-script / scriptPubkey: 4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac
Txout-script / Parsed scriptPubkey: 04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f OP_CHECKSIG 
```

`$ ./a.out tx_703fc5ee.bin`

```
Tx Version: 1
Tx In-counter: 1
Txin Previous Tx Hash: a59238577c596d2caa367c0855a76a75efcde6953186507fa51ee2dff3eb8b41
Txin Previous Txout-index: 1
Txin-script length: 106
Txin-script / scriptSig: 304402207b9e4d1c1e126f47db3d74f981b8ee9c124f44a92637a657dc94cd4b05216a9a022014fe5df34c6e2c3b1bb1de3f69097873e220b97c0beefd29cc714abeb8180c8801 030e1e08f6d4ba2b71207c961109f9d0b7eaad24b106ecc9b691c297c732d47fcc
Txin sequence_no: ffffffff
Txout Out-counter: 2
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914a31e71f2cfc0327c55cc4026073f06f3e9e1a21a88ac
Txout-script / Parsed scriptPubkey: OP_DUP OP_HASH160 a31e71f2cfc0327c55cc4026073f06f3e9e1a21a OP_EQUALVERIFY OP_CHECKSIG 
Txout Value: 10000000000
Txout-script length: 25
Txout-script / scriptPubkey: 76a914d6bbf4f08d2df7ea32b2930ae4b7436d4ca6fe4b88ac
Txout-script / Parsed scriptPubkey: OP_DUP OP_HASH160 d6bbf4f08d2df7ea32b2930ae4b7436d4ca6fe4b OP_EQUALVERIFY OP_CHECKSIG 
```

调试的结果和在 [webbtc-tx0](https://webbtc.com/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b.json), [webbtc-tx703fc5ee](https://webbtc.com/tx/703fc5ee3e311238ff9d41977ffb072fb03a2ea8a9a8f5fa3ca69d3bd3fa16a7.json) 上查询的结果一致.


## 2. 构造创世交易

我们可以认为一笔交易由三部分构成:

1\. 交易自身的数据, 这些数据有: Version no, In-counter, Out-counter, lock_time 等;

2\. 交易输入数据, 记作 Txin;

3\. 交易输出数据, 记作 Txout;

### 2.1 构造交易的演示程序

首先我们给出一张创世交易 TX0 的简化图,

![Tx0简化图](/images/Tx0_in_out.jpg)

在上面的图中，我们将 TX0 的其他信息去掉了，只保留了 Txin 和 Txout 两部分的信息, 其中 In 部分包含一个 scriptSig, Out 部分包含一个 scriptPubKey.

TX0 的交易类型是: Obsolete pay-to-pubkey transaction. Obsolete 是 **_过时_** 的意思, 即 TX0 使用了 pay-to-pubkey 这种过时的交易类型，pay-to-pubkey 虽然过时了，但是比特币系统仍然会认为这种交易是合法的或者认为包含这种过时交易的历史数据是合法的。

pay-to-pubkey 这种交易的 Checking process 如下:

|Stack|	Script|	Description|
|-----|-------|------------|
|Empty.|	<sig> <pubKey> OP_CHECKSIG	|scriptSig and scriptPubKey are combined.|
|\<sig\> \<pubKey\>	|OP_CHECKSIG	|Constants are added to the stack.|
|true	|Empty.	|Signature is checked for top two stack items.|

<br/>

我们注意这句话: **_scriptSig and scriptPubKey are combined_**, 这句话的意思是将 scriptSig 和 scriptPubKey 合并起来, 如果我们刨去一些细节然后对
Checking process 进行提炼，那么 Checking process 的核心可以理解为,

> 将 scriptSig 和 scriptPubKey 两个脚本合并为一个脚本，然后执行合并后的脚本.

我们回到 TX0 中, TX0 中已经包含了一个 scriptSig 和一个 scriptPubKey, 那么 Checking process 是要将 TX0 中的 scriptSig 和 scriptPubKey 和并起来吗？显然不是这样的, 这里的 scriptSig 和 scriptPubKey 虽然处在同一笔交易即 TX0 中，但是两者其实是没有联系的。scriptPubKey 要合并的对象是下一笔交易的 Txin 中的 scriptSig. 在这里我们依然刨去一些细节，对创建交易这一过程进行一个抽象:

> 已知脚本 P, 求一脚本 S, 这个 S 满足条件: 当 S 和 P 按序合并为脚本 SP, 执行脚本 SP 后能够得到预期结果, 比如结果为 True.

现在我们根据上述抽象出来的概念来解释下为什么窃取了 private key, 就能窃取比特币。

![bitcoin 转移简化图](/images/bitcoin_trans2.jpg)

1\. 首先构造一个不含 scriptSig 的交易, 记作 Tx\_unsig

2\. 对 Tx\_unsig 作一个数字摘要，将此摘要记作 Dtxu

3\. 用公钥 pbk\_A 对应的私钥 prk\_A 对数字摘要 Dtxu 进行一个加密 得到 SigD, 这个 SigD 就是我们要求的 scriptSig: S

4\. 将 S 放到 Tx\_unsig 中，这时就生成了一个包含 scriptSig 的完整的交易 Tx\_sig

公钥 pbk\_A 能够将 S 解密成 Dtxu, `<S> <pbk_A> OP_CHECKSIG` 的求值结果为 `True`, 所以 Tx\_sig 将是一笔合法的交易。

由于我并没有中本聪的私钥，所以我没有办法用代码去演示怎么转移掉 TX0 中的 50 个比特币，但是我们仍然可以对 [Block#170](https://webbtc.com/block/00000000d1145790a8694403d4063f323d499e655c83426834d4ce2f8dd4a2ee) 中的已经发生的交易用代码进行分析并演示怎么创建可用的交易。

![block#170交易演示](/images/block170_tx_demo.jpg)

我们的演示程序将分为客户端和服务端两部分, 客户端程序创建交易数据，并将数据通过网络提交给服务端，服务端程序将验证交易数据，并保存交易数据。
那么客户端怎么和服务端通信呢？答案是我们需要制定一些协议来指导两者间的通信。当然比特币已经有了一套比较完备的协议，我们
直接使用比特币的协议即可。由于我们要做的只是一个 demo 程序，我们并不需要把比特币的所有协议都实现，我们只需要实现其中和交易相关的协议。

#### 2.1.1 Message structure 即消息结构

这是一个通用的结构(Common structures), 即比特币节点之间的每一个消息的结构都是相同的, 当然消息的内容(payload)是不同的。

[https://en.bitcoin.it/wiki/Protocol_documentation#Message_structure](https://en.bitcoin.it/wiki/Protocol_documentation#Message_structure)

**Message structure**

|Field Size	|Description	|Data type	|Comments|
|-----------|---------------|-----------|--------|
|4	|magic	|uint32_t	|Magic value indicating message origin network, and used to seek to next message when stream state is unknown|
|12	|command	|char[12]	|ASCII string identifying the packet content, NULL padded (non-NULL padding results in packet rejected)|
|4	|length	|uint32_t	|Length of payload in number of bytes|
|4	|checksum	|uint32_t	|First 4 bytes of sha256(sha256(payload))|
| ?	|payload	|uchar[]	|The actual data|

<br/>

已有的 magic values:

|Network|	Magic value	|Sent over wire as|
|-------|---------------|-----------------|
|main	|0xD9B4BEF9	|F9 BE B4 D9|
|testnet|	0xDAB5BFFA|	FA BF B5 DA|
|testnet3|	0x0709110B|	0B 11 09 07|
|namecoin|	0xFEB4BEF9|	F9 BE B4 FE|

<br/>

我们的 demo 程序将参照上面的 message structure 构造 message.

#### 2.1.2 Message types 即消息类型

[https://en.bitcoin.it/wiki/Protocol_documentation#Message_types](https://en.bitcoin.it/wiki/Protocol_documentation#Message_types)

比特币的消息类型很多，我们暂时只分析 version, verack, tx 这3种消息，因为客户端发送一笔交易只涉及到这3种消息。

下面 3 种消息的通用结构是一致的, 不同的是 payload 结构，我们只分析它们的 payload 结构.

1\. **version**

在发送交易之前，我们首先要发送 version 消息

[https://en.bitcoin.it/wiki/Protocol_documentation#version](https://en.bitcoin.it/wiki/Protocol_documentation#version)

|Field Size|	Description	|Data type	|Comments|
|----------|----------------|-----------|--------|
|4	|version	|int32_t	|Identifies protocol version being used by the node|
|8	|services	|uint64_t	|bitfield of features to be enabled for this connection|
|8	|timestamp	|int64_t	|standard UNIX timestamp in seconds|
|26	|addr_recv	|net_addr	|The network address of the node receiving this message|
|Fields below require version ≥ 106|
|26	|addr_from	|net_addr	|The network address of the node emitting this message|
|8	|nonce	|uint64_t	|Node random nonce, randomly generated every time a version packet is sent. This nonce is used to detect connections to self.|
| ?	|user_agent	|var_str|	User Agent (0x00 if string is 0 bytes long)|
|4	|start_height	|int32_t	|The last block received by the emitting node|
|Fields below require version ≥ 70001|
|1	|relay	|bool	|Whether the remote peer should announce relayed transactions or not, see BIP 0037|

<br/>

2\. **verack**

如果我们前面发送的 version 消息是正确的，我们会得到一个 verack 响应.

[https://en.bitcoin.it/wiki/Protocol_documentation#verack](https://en.bitcoin.it/wiki/Protocol_documentation#verack)

> The verack message is sent in reply to version. This message consists of only a message header with the command string "verack".

也就是说 verack 消息是用于响应 version 消息的，并且只有 message header, 没有 payload, 并且它的 header 包含字符串 "verack".

Hexdump of the verack message:

```
0000   F9 BE B4 D9 76 65 72 61  63 6B 00 00 00 00 00 00   ....verack......
0010   00 00 00 00 5D F6 E0 E2                            ........

Message header:
 F9 BE B4 D9                          - Main network magic bytes
 76 65 72 61  63 6B 00 00 00 00 00 00 - "verack" command
 00 00 00 00                          - Payload is 0 bytes long
 5D F6 E0 E2                          - Checksum
```

3\. **tx**

这个才是我们的主角，它的 payload 结构其实就是一个交易: Tx.

[https://en.bitcoin.it/wiki/Protocol_documentation#tx](https://en.bitcoin.it/wiki/Protocol_documentation#tx)

我们已经在第 1 节里对 Tx 的结构解析做了大量的工作，这里就不再重复叙述 Tx 的结构了.


#### 2.1.3 发送交易

#### 2.1.4 验证交易

### 2.2 构建我们自己的创世交易

## 3. 构造创世区块

